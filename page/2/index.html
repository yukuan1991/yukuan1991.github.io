<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Sponge的个人博客">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Sponge的个人博客">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Sponge的个人博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/">





  <title>Sponge的个人博客</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Sponge的个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/28/前端知识归纳（7）-JS应用开发（part2-Ajax）/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sponge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sponge的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/28/前端知识归纳（7）-JS应用开发（part2-Ajax）/" itemprop="url">前端知识归纳（7）-- JS应用开发（part2 Ajax）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-28T10:20:22+08:00">
                2019-01-28
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/01/28/前端知识归纳（7）-JS应用开发（part2-Ajax）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/01/28/前端知识归纳（7）-JS应用开发（part2-Ajax）/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  654
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  2
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><p>官网的第一句话：</p>
<blockquote>
<p><strong>JSON</strong> (JavaScript Object Notation) is a lightweight data-interchange format.</p>
</blockquote>
<p>JSON 是一种轻量级的数据交换格式。JSON 是一种格式，而不是对象，所以别再说“这个 JSON 对象有问题”这种话。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123; // 这是一个对象字面量，和 JSON 无关</span><br><span class="line">    &quot;hello&quot;: &quot;JSON&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var b = [ // 这是一个数组字面量，和 JSON 无关</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;hello&quot;: &quot;JSON&quot;</span><br><span class="line">    &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">var c = &apos;&#123;&quot;hello&quot;:&quot;JSON&quot;&#125;&apos;; // 这是一个字符串变量，和 JSON 有一点关系</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;hello&quot;:&quot;JSON&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>这才是 JSON ，JSON 就是文本，和什么语言没有关系，JS 可以解析，自然 JAVA、Python 都可以解析，所以<code>{&quot;hello&quot;:function () {}}</code>不是一个 JSON 是不是就很容易理解了，你这个 <code>function</code>放在 JAVA 里面算个什么回事？！</p>
<p>当然，它是有格式的文本，至于什么格式，看官网 <a href="http://json.org/" target="_blank" rel="noopener">http://json.org/</a> 就好了。</p>
<h1 id="jqXHR"><a href="#jqXHR" class="headerlink" title="jqXHR"></a>jqXHR</h1><p><strong>jqXHR</strong> 是一个对象，是 jQuery 中的 XHR 的对象，影响了一代人。</p>
<p>你辛辛苦苦的写了下面这个代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">xhr.onreadystatechange = () =&gt; &#123;</span><br><span class="line">    if (xhr.readyState === 4) &#123;</span><br><span class="line">        // todo</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(xhr.status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">xhr.open(&apos;get&apos;, &apos;data.json&apos;);</span><br><span class="line">xhr.send(null);</span><br></pre></td></tr></table></figure>
<p>使用 jQuery 只用这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.getJSON(&apos;data.json&apos;, function() &#123;</span><br><span class="line">    // todo</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>我想没人不喜欢这样写吧，具体可以参考 <a href="http://api.jquery.com/jquery.getjson/" target="_blank" rel="noopener">http://api.jquery.com/jquery.getjson/</a> 。所以很多人认为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API" target="_blank" rel="noopener">Fetch</a> 的出现就是受到 jQuery 的影响。</p>
<p><code>$.getJSON</code> 是一个简写，jQuery 的 ajax 有更底层的接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    dataType: &apos;json&apos;,</span><br><span class="line">   url: &apos;data.json&apos;,</span><br><span class="line">   success: function() &#123;</span><br><span class="line">        // todo</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>别忘了我们的题目是 jqXHR ，所以接口什么的不多说，更详细的介绍可以参考这里：<a href="http://api.jquery.com/jQuery.ajax/" target="_blank" rel="noopener">http://api.jquery.com/jQuery.ajax/</a> 。</p>
<p>给上面的代码赋个值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const jqXHR = $.ajax(&#123;</span><br><span class="line">    dataType: &apos;json&apos;,</span><br><span class="line">   url: &apos;data.json&apos;,</span><br><span class="line">   success: function() &#123;</span><br><span class="line">        // todo</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>没错，所有的 jQuery ajax 返回值，不管是 <code>ajax()</code> 底层还是 <code>getJSON()</code> 高阶，都是返回 jqXHR 对象。</p>
<p>jqXHR 是原生 XHR 的封装，原生有的它都有，原生没有的，它也有。</p>
<blockquote>
<p>The jqXHR objects returned by <code>$.ajax()</code> as of jQuery 1.5 implement the Promise interface, giving them all the properties, methods, and behavior of a Promise.</p>
</blockquote>
<p>注意 <strong>Promise</strong> 字眼，Promise 是你们必须要掌握的东西，因为它是所有异步编程技术的基础，可以看看下面的参考资料。</p>
<p>而 Promise 带给 jqXHR 的变化，就是像下面这样写代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$.getJSON()</span><br><span class="line"> .done((data) =&gt; &#123; // todo &#125;)</span><br><span class="line">   .done((data) =&gt; &#123; // todo again &#125;)</span><br><span class="line">    .fail((err) =&gt; &#123; // if error &#125;)</span><br></pre></td></tr></table></figure>
<p>这就是为什么要聊聊 <strong>jqXHR</strong> 。</p>
<p>向 jQuery 致敬。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.gitbook.com/book/wohugb/promise/details" target="_blank" rel="noopener">JavaScript Promise迷你书（中文版）</a></li>
<li><a href="http://api.jquery.com/jQuery.ajax/#jqXHR" target="_blank" rel="noopener">http://api.jquery.com/jQuery.ajax/#jqXHR</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/28/前端知识归纳（7）-JS应用开发（part1-正则表达式）/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sponge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sponge的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/28/前端知识归纳（7）-JS应用开发（part1-正则表达式）/" itemprop="url">前端知识归纳（7）-- JS应用开发（part1 正则表达式）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-28T09:40:49+08:00">
                2019-01-28
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/01/28/前端知识归纳（7）-JS应用开发（part1-正则表达式）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/01/28/前端知识归纳（7）-JS应用开发（part1-正则表达式）/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  233
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p><img src="/2019/01/28/前端知识归纳（7）-JS应用开发（part1-正则表达式）/regexp.png" alt="regexp.png"></p>
<h2 id="flags"><a href="#flags" class="headerlink" title="flags"></a>flags</h2><ul>
<li>i 忽略大小写</li>
<li>g 全局查找</li>
<li>m 多行查找<h2 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h2><img src="/2019/01/28/前端知识归纳（7）-JS应用开发（part1-正则表达式）/regexp-1.png" alt="regexp-1.png"></li>
</ul>
<h2 id="分组与捕获"><a href="#分组与捕获" class="headerlink" title="分组与捕获"></a>分组与捕获</h2><p><code>/(01){3}/</code>  ()代表分组<br>可以通过RexExp.exec()方法获取捕获的分组<br><code>/(?:01)/</code>非捕获型分组 即分组括号内加上?:</p>
<h2 id="引用和反向引用"><a href="#引用和反向引用" class="headerlink" title="引用和反向引用"></a>引用和反向引用</h2><p><code>var reg = /(01){3}/.exec(&#39;20010101&#39;);</code><br><code>reg[0]</code>或者<code>reg.$1</code> 代表引用</p>
<p><code>var reg = /&lt;(div)&gt;.*&lt;\/\1&gt;/</code><br><code>\1</code>反向引用</p>
<h2 id="惰性匹配"><a href="#惰性匹配" class="headerlink" title="惰性匹配"></a>惰性匹配</h2><p>贪婪匹配: 普通量词<br>惰性匹配: 普通量词加?<br>例：<code>/\d+?/</code></p>
<h2 id="正向前瞻和负向前瞻"><a href="#正向前瞻和负向前瞻" class="headerlink" title="正向前瞻和负向前瞻"></a>正向前瞻和负向前瞻</h2><p><code>/jero (?= love coding)/</code> 正向前瞻即分组括号内加?=<br><code>/jero (?! love girl)/</code> 负向前瞻即分组括号内加?!</p>
<p><code>/(?= love coding)/</code>  匹配位置<br><code>/(?! love girl)/</code></p>
<h2 id="String能使用正则的方法"><a href="#String能使用正则的方法" class="headerlink" title="String能使用正则的方法"></a>String能使用正则的方法</h2><ul>
<li>replace()</li>
<li>match()    与exec()区别，exec()捕获第一个符合分组条件的字符串，而match()则会将所有符合分组条件的子串都捕获出来</li>
<li>split()</li>
<li>search()</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions" target="_blank" rel="noopener">RegExp | MDN</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/28/前端知识归纳（6）-性能与工程化（part3-模块化）/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sponge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sponge的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/28/前端知识归纳（6）-性能与工程化（part3-模块化）/" itemprop="url">前端知识归纳（6）-- 性能与工程化（part3 模块化）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-28T09:26:32+08:00">
                2019-01-28
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/01/28/前端知识归纳（6）-性能与工程化（part3-模块化）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/01/28/前端知识归纳（6）-性能与工程化（part3-模块化）/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.7k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  10
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="立即调用的函数表达式（IIFE）"><a href="#立即调用的函数表达式（IIFE）" class="headerlink" title="立即调用的函数表达式（IIFE）"></a>立即调用的函数表达式（IIFE）</h1><p>大家在学习 JavaScript 的过程中，可能会看到许多下面的或者类似的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">  //do something here;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>对于上面的代码，有两种说法，一部分人称之为 <strong>自执行的匿名函数（self-executing anonymous function）</strong>，另外一部分则更为推崇 <a href="http://benalman.com/news/2010/11/immediately-invoked-function-expression/#iife" target="_blank" rel="noopener">Ben Alman</a> 的叫法：<strong>立即调用的函数表达式（IIFE，Immediately-Invoked Function Expression ）</strong>。事实上，大家可以按照自己的理解来选择符合的说法。</p>
<h2 id="立即调用函数会报错"><a href="#立即调用函数会报错" class="headerlink" title="立即调用函数会报错"></a>立即调用函数会报错</h2><p>在Javascript中，一对圆括号<code>()</code>是一种运算符，我们可以使用圆括号来调用一个函数，如调用 <code>sayHello</code> 方法则可以这样做。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var sayHello = function() &#123;</span><br><span class="line">  // some code</span><br><span class="line">&#125;</span><br><span class="line">// 使用圆括号表达式调用</span><br><span class="line">sayHello();</span><br></pre></td></tr></table></figure>
<p>有时候，我们可能会和上面的代码一样，在定义一个函数后，立即且只调用一次该函数。然而当我们按照下面这样写的时候，发现会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 定义了一个匿名函数</span><br><span class="line">function () &#123;</span><br><span class="line">  // some code</span><br><span class="line">&#125;();</span><br><span class="line">// SyntaxError: Unexpected token (</span><br></pre></td></tr></table></figure>
<p>之所以产生这个错误的原因是，JavaScript引擎在解析发现 <code>function</code> 关键字出现在行首，认为这一段代码是函数申明语句，因此在 <code>function</code> 关键字后面需要的是一个函数标识符名称，而对于标识符来说是不能以 <code>(</code> 来命名的。</p>
<p>因此，我们给该函数加上命名。但是发现还是会报一个不一样的错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 定义了一个匿名函数</span><br><span class="line">function sayHello() &#123;</span><br><span class="line">  // some code</span><br><span class="line">&#125;();</span><br><span class="line">// SyntaxError: Unexpected token )</span><br></pre></td></tr></table></figure>
<p>原因其实前面也提及到了，JavaScript引擎在解析发现 <code>function</code> 关键字出现在行首，认为这一段代码是函数申明语句。而函数申明语句并不能通过圆括号 <code>()</code> 来结尾，因此就报错了。</p>
<h2 id="立即调用的函数表达式"><a href="#立即调用的函数表达式" class="headerlink" title="立即调用的函数表达式"></a>立即调用的函数表达式</h2><p>上面的问题的解决方法就是，让我们<strong>函数申明语句</strong>转换成<strong>函数表达式</strong>，即使 <code>function</code> 关键字不出现在行首，让 JavaScript 解析引擎将其理解为一个表达式，避免错误。要使其成为一个表达式，有很多种方法。其中最简单且最容易阅读的方式，便是使用圆括号来实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123; /* some code */ &#125;());</span><br><span class="line">// 或者可以这样写</span><br><span class="line">(function()&#123; /* some code */ &#125;)();</span><br></pre></td></tr></table></figure>
<p>因此我们把上面的表达式叫做 <strong>立即调用的函数表达式(Immediately-Invoked Function Expression)</strong> 也就是 <strong>IIFE</strong>。</p>
<h2 id="其他的写法"><a href="#其他的写法" class="headerlink" title="其他的写法"></a>其他的写法</h2><p>除了上面的写法外，还有许多能够让 JavaScript 解析器解析成表达式的写法，如下面的写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">true &amp;&amp; function()&#123; /* some code */ &#125;();</span><br><span class="line"></span><br><span class="line">// 或者使用操作符</span><br><span class="line">!function()&#123; /* some code */ &#125;();</span><br><span class="line">~function()&#123; /* some code */ &#125;();</span><br><span class="line">-function()&#123; /* some code */ &#125;();</span><br><span class="line">+function()&#123; /* some code */ &#125;();</span><br></pre></td></tr></table></figure>
<h2 id="IIFE-的好处"><a href="#IIFE-的好处" class="headerlink" title="IIFE 的好处"></a>IIFE 的好处</h2><p>大多数情况，我们使用到 <strong>IIFE</strong> ，并不会被再次调用，因此我们通常会使用<strong>匿名函数</strong>，即忽略立即执行的函数的函数名称。</p>
<p>我们可以使用 <strong>IIFE</strong> 来形成了一个私有的作用域（模拟块级作用域），因此我们可以封装想要的私有变量，以及避免变量出现冲突的情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 可被访问 canRead</span><br><span class="line">var canRead = 2;</span><br><span class="line">var same = 1;</span><br><span class="line"></span><br><span class="line">// 私有变量 noRead</span><br><span class="line">(function ()&#123;</span><br><span class="line">  var noRead = 3;</span><br><span class="line">  var same = 2;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">console.log(canRead); // 2</span><br><span class="line">console.log(noRead); // noRead is not defined</span><br><span class="line">// IIFE 定义变量不会污染外部的变量</span><br><span class="line">console.log(same); // 1</span><br></pre></td></tr></table></figure>
<h2 id="IIFE-创建-Module"><a href="#IIFE-创建-Module" class="headerlink" title="IIFE 创建 Module"></a>IIFE 创建 Module</h2><p>我们可以利用 <strong>IIFE</strong> 来创建私有的函数作用域，不仅可以避免变量冲突还可以创建私有变量和方法，十分适合用来创建一个模块，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个立即调用的匿名函数表达式</span><br><span class="line">// return一个变量，其中这个变量里包含你要暴露的东西</span><br><span class="line">// 返回的这个变量将赋值给 module</span><br><span class="line">var module = (function() &#123;</span><br><span class="line">  var num = 1;</span><br><span class="line">  return &#123;</span><br><span class="line">    get: function () &#123;</span><br><span class="line">      return num;</span><br><span class="line">    &#125;,</span><br><span class="line">    set: function (value) &#123;</span><br><span class="line">      num = value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<h2 id="更多阅读"><a href="#更多阅读" class="headerlink" title="更多阅读"></a>更多阅读</h2><ul>
<li><a href="http://benalman.com/news/2010/11/immediately-invoked-function-expression/#iife" target="_blank" rel="noopener">IIFE by Ben Alman</a></li>
<li><a href="http://javascript.ruanyifeng.com/grammar/function.html#toc24" target="_blank" rel="noopener">立即调用的函数表达式（IIFE）- 阮一峰</a></li>
</ul>
<h1 id="CMD-amp-SeaJS"><a href="#CMD-amp-SeaJS" class="headerlink" title="CMD &amp; SeaJS"></a>CMD &amp; SeaJS</h1><p>CMD（Common Module Definition） 通用模块定义。其是国内前端大牛玉伯的杰作，而 SeaJS 则是 CMD 规范的模块加载器即具体实现。然而随着前端的发展，SeaJS 已经逐渐退出了前端的舞台了。因此这里只会稍微给大家讲解下 CMD 和 SeaJS 的一些知识点。大家了解下就好。</p>
<h2 id="CMD-和-AMD"><a href="#CMD-和-AMD" class="headerlink" title="CMD 和 AMD"></a>CMD 和 AMD</h2><p>通常我们会拿 CMD 规范来和 AMD 规范进行对比。那么 AMD 和 CMD 有什么区别和对比的呢？</p>
<h3 id="申明依赖模块不同"><a href="#申明依赖模块不同" class="headerlink" title="申明依赖模块不同"></a>申明依赖模块不同</h3><p>对于依赖的模块，AMD 和 CMD 的处理方式是不一样的。</p>
<ul>
<li>AMD <strong>推崇依赖前置</strong>，在定义模块的时候就要声明其依赖的模块。</li>
<li>CMD <strong>推崇依赖就近</strong>，只有在用到某个模块的时候再去 require 。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// CMD</span><br><span class="line">define(function(require, exports, module) &#123;</span><br><span class="line">  var a = require(&apos;./a&apos;)</span><br><span class="line">  a.doSomething()</span><br><span class="line">  // 依赖可以就近书写</span><br><span class="line">  var b = require(&apos;./b&apos;) </span><br><span class="line">  b.doSomething()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// AMD 默认推荐的是 依赖必须一开始就写好</span><br><span class="line">define([&apos;./a&apos;, &apos;./b&apos;], function(a, b) &#123; </span><br><span class="line">  a.doSomething()</span><br><span class="line">  b.doSomething()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="执行依赖模块时机"><a href="#执行依赖模块时机" class="headerlink" title="执行依赖模块时机"></a>执行依赖模块时机</h3><ul>
<li>AMD 提前执行依赖（异步加载：依赖先执行）+延迟执行</li>
<li>CMD 延迟执行依赖（运行到需加载，根据顺序执行）</li>
</ul>
<h3 id="加载器"><a href="#加载器" class="headerlink" title="加载器"></a>加载器</h3><p>AMD 是 <code>RequireJS</code> 在推广过程中对模块定义的规范化产出。<br>CMD 是 <code>SeaJS</code> 在推广过程中对模块定义的规范化产出。</p>
<h2 id="使用SeaJS"><a href="#使用SeaJS" class="headerlink" title="使用SeaJS"></a>使用SeaJS</h2><p>SeaJS 是 CMD 规范的具体实现。使用 SeaJS 和使用 requireJS 十分类似，只是写法上稍微有所不同，具体如下：</p>
<ol>
<li>引入 SeaJS 的库</li>
<li>定义模块（define）</li>
<li>暴露模块接口（exports）</li>
<li>加载依赖模块（require）</li>
</ol>
<p>如下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;./sea.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  define(function (require,exports,module) &#123;</span><br><span class="line">      // exports : 对外的接口</span><br><span class="line">      // requires : 依赖的模块</span><br><span class="line">      require(&apos;./a.js&apos;);//如果地址是一个模块的话，那么require的返回值就是模块中的exports</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h2 id="SeaJS（CMD）为什么被淘汰"><a href="#SeaJS（CMD）为什么被淘汰" class="headerlink" title="SeaJS（CMD）为什么被淘汰"></a>SeaJS（CMD）为什么被淘汰</h2><p>事实上，在过去 SeaJS（CMD） 曾经颇具影响力，为什么要逐渐被淘汰了呢？</p>
<p>感兴趣的同学可以带着这样的问题，阅读下面的帖子。<br><a href="https://www.zhihu.com/question/34756861" target="_blank" rel="noopener">Sea.js作者发布微博: 应该给 Sea.js 和 KISSY 也树一块墓碑了。 为啥啊?过时了吗?</a></p>
<h2 id="更多阅读-1"><a href="#更多阅读-1" class="headerlink" title="更多阅读"></a>更多阅读</h2><ul>
<li><a href="https://github.com/seajs/seajs/issues/242" target="_blank" rel="noopener">SeaJS 规范文档</a></li>
<li><a href="https://github.com/seajs/seajs/issues/269" target="_blank" rel="noopener">从 CommonJS 到 Sea.js</a></li>
</ul>
<h1 id="面向未来的-ES6-模块标准"><a href="#面向未来的-ES6-模块标准" class="headerlink" title="面向未来的 ES6 模块标准"></a>面向未来的 ES6 模块标准</h1><p>既然模块化已经越来越重要，那么从语言层面上直接去解决这个问题就显得很有必要（况且其他语言早就有了）。于是 ES6 直接在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</p>
<h2 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h2><p>简单来说，ES6 模块的设计思想就是：一个 JS 文件就代表一个 JS 模块。在模块中你可以使用 import 和 export 关键字来导入或导出模块中的东西。</p>
<p>ES6 模块主要具备以下几个基本特点：</p>
<ul>
<li>自动开启严格模式，即使你没有写 <code>use strict</code></li>
<li>每个模块都有自己的上下文，每一个模块内声明的变量都是局部变量，不会污染全局作用域</li>
<li>模块中可以导入和导出各种类型的变量，如函数，对象，字符串，数字，布尔值，类等</li>
<li>每一个模块只加载一次，每一个 JS 只执行一次， 如果下次再去加载同目录下同文件，直接从内存中读取。 一个模块就是一个单例，或者说就是一个对象</li>
</ul>
<h2 id="export"><a href="#export" class="headerlink" title="export"></a>export</h2><p>export 命令用于规定模块的对外接口。如果你希望外部能够读取模块内部的变量，函数或类等，就必须使用 export 关键字输出该内容。</p>
<p>下面我们以个人所得税计算为一个模块，来具体使用下 export：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">// 个人所得税计算模块</span><br><span class="line">// 在线参考站点：[个人所得税](http://www.gerensuodeshui.cn/)</span><br><span class="line">// personal-income-tax.js</span><br><span class="line"></span><br><span class="line">// 个税起征点</span><br><span class="line">export const taxBasicNum = 3500;</span><br><span class="line"></span><br><span class="line">// 税率等级</span><br><span class="line">export const taxRatioLevel = [</span><br><span class="line">    &#123;</span><br><span class="line">        num: 1500, // 小于1500</span><br><span class="line">        ratio: &apos;3%&apos;,</span><br><span class="line">        subtract: 0, // 速算扣除数</span><br><span class="line">    &#125;, </span><br><span class="line">    &#123;</span><br><span class="line">        num: 4500, // 大于1500，小于4500</span><br><span class="line">        ratio: &apos;10%&apos;,</span><br><span class="line">        subtract: 105,</span><br><span class="line">    &#125;, </span><br><span class="line">    &#123;</span><br><span class="line">        num: 9000, // 大于4500，小于9000</span><br><span class="line">        ratio: &apos;20%&apos;,</span><br><span class="line">        subtract: 555,</span><br><span class="line">    &#125;, </span><br><span class="line">    &#123;</span><br><span class="line">        num: 35000, // 大于9000，小于35000</span><br><span class="line">        ratio: &apos;25%&apos;,</span><br><span class="line">        subtract: 1005,</span><br><span class="line">    &#125;, </span><br><span class="line">    &#123;</span><br><span class="line">        num: 55000,  // 大于35000，小于55000</span><br><span class="line">        ratio: &apos;30%&apos;,</span><br><span class="line">        subtract: 2755,</span><br><span class="line">    &#125;, </span><br><span class="line">    &#123;</span><br><span class="line">        num: 80000,  // 大于55000，小于80000</span><br><span class="line">        ratio: &apos;35%&apos;,</span><br><span class="line">        subtract: 5505,</span><br><span class="line">    &#125;, </span><br><span class="line">    &#123;</span><br><span class="line">        num: 80000,  // 大于80000</span><br><span class="line">        ratio: &apos;45%&apos;,</span><br><span class="line">        subtract: 13505,</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">// 所缴税收</span><br><span class="line">// 应纳税所得额 = 应发工资 － 五险一金 － 个税起征点</span><br><span class="line">// 所缴税收 = 应纳税所得额 * 税率 - 速算扣除数</span><br><span class="line">export function calTax (num, insurance) &#123;</span><br><span class="line">    let taxShouldNum = num - insurance - taxBasicNum;</span><br><span class="line">    let tax;</span><br><span class="line">    switch (true) &#123;</span><br><span class="line">        case taxShouldNum &lt; taxRatioLevel[0].num:</span><br><span class="line">            tax = taxShouldNum * taxRatioLevel[0].ratio - taxRatioLevel[0].subtract;</span><br><span class="line">            break;</span><br><span class="line">        case taxShouldNum &lt; taxRatioLevel[1].num:</span><br><span class="line">            tax = taxShouldNum * taxRatioLevel[1].ratio - taxRatioLevel[1].subtract;</span><br><span class="line">            break;</span><br><span class="line">        case taxShouldNum &lt; taxRatioLevel[2].num:</span><br><span class="line">            tax = taxShouldNum * taxRatioLevel[2].ratio - taxRatioLevel[2].subtract;</span><br><span class="line">            break;</span><br><span class="line">        case taxShouldNum &lt; taxRatioLevel[3].num:</span><br><span class="line">            tax = taxShouldNum * taxRatioLevel[3].ratio - taxRatioLevel[3].subtract;</span><br><span class="line">            break;</span><br><span class="line">        case taxShouldNum &lt; taxRatioLevel[4].num:</span><br><span class="line">            tax = taxShouldNum * taxRatioLevel[4].ratio - taxRatioLevel[4].subtract;</span><br><span class="line">            break;</span><br><span class="line">        case taxShouldNum &lt; taxRatioLevel[5].num:</span><br><span class="line">            tax = taxShouldNum * taxRatioLevel[5].ratio - taxRatioLevel[5].subtract;</span><br><span class="line">            break;</span><br><span class="line">        case taxShouldNum &gt; taxRatioLevel[6].num:</span><br><span class="line">            tax = taxShouldNum * taxRatioLevel[6].ratio - taxRatioLevel[6].subtract;</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            tax = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return tax;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实发工资</span><br><span class="line">export function calWages(num, insurance) &#123;</span><br><span class="line">    let tax = calTax(num, insurance);</span><br><span class="line">    let wages = num - insurance - tax;</span><br><span class="line"></span><br><span class="line">    return wages;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="import"><a href="#import" class="headerlink" title="import"></a>import</h2><p>使用 export 命令定义了模块的对外接口以后，其他 JS 文件就可以通过 import 命令加载这个模块。现在我们导入前面设计的个人所得税计算模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// main.js</span><br><span class="line">import &#123;taxBasicNum, taxRatioLevel, calTax, calWages&#125; from &apos;./personal-income-tax&apos;;</span><br><span class="line"></span><br><span class="line">// 可以使用 taxBasicNum 输出一段话，说明个税的起征点是多少</span><br><span class="line">console.log(`个税起征点为：taxBasicNum`);</span><br><span class="line">// 还可以使用 taxRatioLevel 数据输出一个表格，对应各个等级的税率，这里就不演示了</span><br><span class="line"></span><br><span class="line">// 计算20000元缴纳了五险一金3000后，应该缴纳多少税收及实际税后工资为多少</span><br><span class="line">let tax = calTax(20000, 3000);</span><br><span class="line">let wages = calWages(20000, 3000);</span><br></pre></td></tr></table></figure>
<h2 id="更多-ES6-模块知识"><a href="#更多-ES6-模块知识" class="headerlink" title="更多 ES6 模块知识"></a>更多 ES6 模块知识</h2><p>通过上面的 export 和 import 的使用，是不是觉得 ES6 的模块很方便，也很简单。当然上面都是些基础的运用，而关于 ES6 模块网上也已经有了很多详细的文档，我们在这就不一一介绍了，这里推荐两篇详细文档以供参考学习：</p>
<ul>
<li><a href="https://segmentfault.com/a/1190000004100661" target="_blank" rel="noopener">[译]JavaScript ES6模块指南</a></li>
<li><a href="http://es6.ruanyifeng.com/#docs/module" target="_blank" rel="noopener">ECMAScript 6 入门之 Module 的语法</a></li>
</ul>
<p>注：目前现代浏览器对 ES6 模块支持程度不同，所以一般都是使用 <a href="https://babeljs.io/" target="_blank" rel="noopener">babel</a> 把 ES6 代码转化为兼容的 ES5 版本的代码。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/25/前端知识归纳（6）-性能与工程化（part2-性能）/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sponge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sponge的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/25/前端知识归纳（6）-性能与工程化（part2-性能）/" itemprop="url">前端知识归纳（6）-- 性能与工程化（part2 性能）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-25T09:58:57+08:00">
                2019-01-25
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/01/25/前端知识归纳（6）-性能与工程化（part2-性能）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/01/25/前端知识归纳（6）-性能与工程化（part2-性能）/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  5.8k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  22
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="performance-详解"><a href="#performance-详解" class="headerlink" title="performance 详解"></a>performance 详解</h1><p>为了更加精确地测量和提高网页和Web应用程序的性能够，W3C 和各浏览器厂商共同制定了 <strong>Web Performance API</strong>。</p>
<p>我们可以通过该接口查看用户访问网站各项性能数据，如连接建立时间、dns时间等信息，为更好地增强网页性能提供了前所未有的支持。</p>
<h2 id="浏览器内存相关-performance-memory"><a href="#浏览器内存相关-performance-memory" class="headerlink" title="浏览器内存相关 performance.memory"></a>浏览器内存相关 performance.memory</h2><p><code>performance.memory</code> 可获取浏览器的内存情况,这个属性并不是标准的performance 属性，只在 chrome浏览器中。具体有以下值：</p>
<ul>
<li><code>usedJSHeapSize</code> 表示所有被使用的 js 堆栈内存</li>
<li><code>totalJSHeapSize</code> 表示当前 js 堆栈内存总大小</li>
<li><code>jsHeapSizeLimit</code> 表示内存大小限制</li>
</ul>
<p>其中 <code>usedJSHeapSize</code> 不能大于 <code>totalJSHeapSize</code>，如果大于则可能出现了内存泄漏的情况。</p>
<h2 id="网页导航相关-performance-navigation"><a href="#网页导航相关-performance-navigation" class="headerlink" title="网页导航相关 performance.navigation"></a>网页导航相关 performance.navigation</h2><p><code>performance.navigation</code> 对象存储了两个属性，它们表示触发页面加载的原因。这些原因可能是页面重定向、前进后退按钮或者普通的 URL 加载。两个属性如下：</p>
<h3 id="performance-navigation-type"><a href="#performance-navigation-type" class="headerlink" title="performance.navigation.type"></a>performance.navigation.type</h3><p>该属性的值为一个整数值，表示网页的加载来源，共以下4种情况。</p>
<table>
<thead>
<tr>
<th>数值</th>
<th>含义</th>
<th>相应的常量</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>通过点击链接、地址栏输入、表单提交、脚本操作等方式加载。</td>
<td>TYPE_NAVIGATENEXT</td>
</tr>
<tr>
<td>1</td>
<td>通过刷新操作或者 location.reload() 方法</td>
<td>TYPE_RELOAD</td>
</tr>
<tr>
<td>2</td>
<td>通过历史遍历操作加载</td>
<td>TYPE_BACK_FORWARD</td>
</tr>
<tr>
<td>255</td>
<td>其他来源的加载</td>
<td>TYPE_UNDEFINED</td>
</tr>
</tbody>
</table>
<h3 id="performance-navigation-redirectCount"><a href="#performance-navigation-redirectCount" class="headerlink" title="performance.navigation.redirectCount"></a>performance.navigation.redirectCount</h3><p>该属性表示到达当前页面，经过重定向的次数。</p>
<h2 id="时间相关-performance-timing"><a href="#时间相关-performance-timing" class="headerlink" title="时间相关 performance.timing"></a>时间相关 performance.timing</h2><p><code>performance.timing</code> 对象包含了各种浏览器性能相关的信息如网站建立连接、DNS查询、DOM 解析等各项数据，使我们能够更为全面精确地了解网页性能的详细情况。</p>
<p><img src="/2019/01/25/前端知识归纳（6）-性能与工程化（part2-性能）/performance.png" alt="performance.png"></p>
<p>以下是相关的属性：</p>
<ul>
<li><strong>navigationStart</strong>：当前浏览器窗口的前一个网页关闭，发生unload事件时的时间。如果没有上一个页面，这个值会和 <code>fetchStart</code> 相同。通常我们也理解为准备加载新页面的起始时间。</li>
<li><strong>redirectStart</strong>：到当前页面的重定向开始的时间。当重定向的页面来自同一个域时这个属性才会有值，否则值为0。</li>
<li><strong>redirectEnd</strong>：到当前页面的重定向结束的时间。当重定向的页面来自同一个域时这个属性才会有值，否则值为0。</li>
<li><strong>fetchStart</strong>：准备使用HTTP请求(fetch)页面的时间。</li>
<li><strong>domainLookupStart</strong>：域名查询开始的时间。</li>
<li><strong>domainLookupEnd</strong>：域名查询结束的时间。</li>
<li><strong>connectStart</strong>：返回HTTP请求开始向服务器发送的时间,如果使用持久连接（persistent connection），则返回值等同于 <code>fetchStart</code> 的值。</li>
<li><strong>(secureConnectionStart)</strong>：可选特性。如果页面是HTTPS协议，则返回开始SSL握手的那个时间。如果当前网页不要求安全连接，则返回0。</li>
<li><strong>connectEnd</strong>：返回浏览器与服务器之间的连接建立的时间。如果建立的是持久连接，则返回值等同于 <code>fetchStart</code> 属性的值。连接建立指的是所有握手和认证过程全部结束。</li>
<li><strong>requestStart</strong>：返回浏览器向服务器发出HTTP请求时（或开始读取本地缓存时）的时间。</li>
<li><strong>responseStart</strong>：返回浏览器从服务器收到（或从本地缓存读取）第一个字节时的时间。</li>
<li><strong>responseEnd</strong>：返回浏览器从服务器收到（或从本地缓存读取）最后一个字节时的时间。</li>
<li><strong>unloadEventStart</strong>：返回同一个域名前一个网页的 <code>unload</code> 事件触发时的时间。否则返回值为0。</li>
<li><strong>unloadEventEnd</strong>：返回同一个域名前一个网页的 <code>unload</code> 事件触发时的时间。否则返回值为0。</li>
<li><strong>domLoading</strong>：返回当前网页 DOM 结构开始解析时（即Document.readyState属性变为 <code>loading</code>、相应的readystatechange事件触发时）的时间</li>
<li><strong>domInteractive</strong>：返回当前网页DOM结构结束解析、开始加载内嵌资源时（即Document.readyState属性变为 <code>interactive</code> 、相应的readystatechange事件触发时）的时间。</li>
<li><strong>domContentLoadedEventStart</strong>：返回当解析器发送 <code>DOMContentLoaded</code> 事件的开始时间</li>
<li><strong>domContentLoadedEventEnd</strong>：返回当文档的 <code>DOMContentLoaded</code> 事件的结束时间。</li>
<li><strong>domComplete</strong>：返回当前文档解析完成，即Document.readyState 变为 <code>complete</code> 且相对应的readystatechange 被触发时的时间。</li>
<li><strong>loadEventStart</strong>：返回该文档下，<code>load</code> 事件被发送时的时间。如果这个事件还未被发送，它的值将会是0。</li>
<li><strong>loadEventEnd</strong>：返回当 <code>load</code> 事件结束，即加载事件完成时的时间。如果这个事件还未被发送，或者尚未完成，它的值将会是0。</li>
</ul>
<h2 id="计算相关节点"><a href="#计算相关节点" class="headerlink" title="计算相关节点"></a>计算相关节点</h2><p>我们可以通过上面的属性计算出许多网页的信息。</p>
<h3 id="页面经历了多长时间"><a href="#页面经历了多长时间" class="headerlink" title="页面经历了多长时间"></a>页面经历了多长时间</h3><p>如下面代码表示距离浏览器开始加载网页到现在的时间间隔。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var timing = performance.timing; </span><br><span class="line">var duration = Date.now() - timing.navigationStart;</span><br></pre></td></tr></table></figure>
<h3 id="网页加载整个过程的-onload-耗时"><a href="#网页加载整个过程的-onload-耗时" class="headerlink" title="网页加载整个过程的(onload)耗时"></a>网页加载整个过程的(onload)耗时</h3><p>如下面代码表示网页加载整个过程的耗时。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var timing = performance.timing; </span><br><span class="line">var pageLoadTime = timing.loadEventEnd - timing.navigationStart;</span><br></pre></td></tr></table></figure>
<h3 id="DNS-域名解析的耗时"><a href="#DNS-域名解析的耗时" class="headerlink" title="DNS 域名解析的耗时"></a>DNS 域名解析的耗时</h3><p>如下面代码表示 DNS 域名解析的耗时。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var timing = performance.timing; </span><br><span class="line">var dns = timing.domainLookupEnd - timing.domainLookupStart;</span><br></pre></td></tr></table></figure>
<h3 id="tcp-连接的耗时"><a href="#tcp-连接的耗时" class="headerlink" title="tcp 连接的耗时"></a>tcp 连接的耗时</h3><p>如下面代码表示 DNS 域名解析的耗时。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var timing = performance.timing; </span><br><span class="line">var tcp = timing.connectEnd - timing.connectStart;</span><br></pre></td></tr></table></figure>
<h3 id="TTFB-获取首字节的耗时"><a href="#TTFB-获取首字节的耗时" class="headerlink" title="TTFB 获取首字节的耗时"></a>TTFB 获取首字节的耗时</h3><p>如下面代码表示 TTFB(time to frist byte ) 获取首字节的耗时。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var timing = performance.timing; </span><br><span class="line">var ttfb = timing.responseStart - timing.navigationStart;</span><br></pre></td></tr></table></figure>
<h2 id="返回时间-performance-now"><a href="#返回时间-performance-now" class="headerlink" title="返回时间 performance.now()"></a>返回时间 performance.now()</h2><p><code>performance.now</code> 方法将会返回当前网页自从<code>performance.timing.navigationStart</code> 到当前时间之间的微秒数（毫秒的千分之一）。</p>
<p>performance.now() 返回的时间近似于 Date.now()。但前者的时间精度是后者的 1000 倍。</p>
<h2 id="资源加载相关-performance-getEntries"><a href="#资源加载相关-performance-getEntries" class="headerlink" title="资源加载相关 performance.getEntries()"></a>资源加载相关 performance.getEntries()</h2><p>浏览器获取网页时，会对网页中每一个资源文件（js、css、图片等）发出一个HTTP请求。<code>performance.getEntries</code>会统计这些请求并且返回相应的时间信息。</p>
<p>如下所说，返回的是第二个HTTP请求的加载情况：<br><img src="/2019/01/25/前端知识归纳（6）-性能与工程化（part2-性能）/performance-entries.png" alt="performance-entries.png"></p>
<h2 id="更多阅读"><a href="#更多阅读" class="headerlink" title="更多阅读"></a>更多阅读</h2><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/performance" target="_blank" rel="noopener">Window.performance - MDN</a></li>
<li><a href="http://javascript.ruanyifeng.com/bom/performance.html#toc4" target="_blank" rel="noopener">Performance APIß</a></li>
</ul>
<h1 id="Date-类型"><a href="#Date-类型" class="headerlink" title="Date 类型"></a>Date 类型</h1><p>在实际应用中，我们常常需要用到日期或者时间等，而在 JS 中，我们通常使用 Date 类型来表示日期。</p>
<p>由于 JS 中的 Date 类型是在早期 Java 中的 java.util.Date 类基础上构建的，所以 JS 的 Date 类型使用的是自 UTC 1970年1月1日0时0分0秒（世界标准时间）起的毫秒数。比如2017年8月7号16时37分26秒, 用毫秒数表示就是 1502095046000。当然，我们实际使用中不需要手动去计算这些毫秒数，但是要理解这个数字的含义。</p>
<h2 id="日期对象"><a href="#日期对象" class="headerlink" title="日期对象"></a>日期对象</h2><p>通常我们调用 <code>new Date()</code> 获取当前时间，函数返回的是日期对象，这个对象有很多方法可以获取日期的信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 当前时间</span><br><span class="line">var now = new Date(); // Tue Aug 08 2017 15:41:26 GMT+0800 (CST)</span><br></pre></td></tr></table></figure>
<p>除此之外，我们还可以传入参数使用，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var today = new Date(1453094034000); // by timestamp(accurate to the millimeter)</span><br><span class="line">var birthday = new Date(&apos;December 17, 1995 03:24:00&apos;);</span><br><span class="line">var birthday = new Date(&apos;1995-12-17T03:24:00&apos;);</span><br><span class="line">var birthday = new Date(1995, 11, 17);</span><br><span class="line">var birthday = new Date(1995, 11, 17, 3, 24, 0);</span><br></pre></td></tr></table></figure>
<p>其参数规则如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// value 代表自1970年1月1日00:00:00 (世界标准时间) 起经过的毫秒数</span><br><span class="line">new Date(value);</span><br><span class="line"></span><br><span class="line">// 表示日期的字符串值</span><br><span class="line">new Date(dateString);</span><br><span class="line"></span><br><span class="line">// year 代表年份的整数值，为了避免2000年问题最好指定4位数的年份; 如使用 1998, 而不要用 98</span><br><span class="line">// month 代表月份的整数值从0（1月）到11（12月）</span><br><span class="line">// day 代表一个月中的第几天的整数值，从1开始</span><br><span class="line">// hour 代表一天中的小时数的整数值 (24小时制)，minute 分钟数，second 秒数，millisecond 毫秒数</span><br><span class="line">new Date(year, month[, day[, hour[, minutes[, seconds[, milliseconds]]]]]);</span><br></pre></td></tr></table></figure>
<p>注：由于日期对象的方法实在有点多，这里就抽取几个常用的说明下，其余的可参考我们下面的参考资料文章。</p>
<h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><h3 id="now-方法"><a href="#now-方法" class="headerlink" title="now 方法"></a>now 方法</h3><p>es5 中添加了 <code>Date.now()</code> 方法，返回表示调用这个方法时的日期和时间的毫秒数。我们经常用此方法来测试代码的运行时间，这样就可以根据运行时间判断其性能了，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 记录开始时间</span><br><span class="line">var start = Date.now();</span><br><span class="line"></span><br><span class="line">// 这里运行一段代码</span><br><span class="line">doSomething();</span><br><span class="line"></span><br><span class="line">// 记录结束时间</span><br><span class="line">var stop = Date.now();</span><br><span class="line"></span><br><span class="line">// 得到代码运行时间</span><br><span class="line">var timeUse = start - stop;</span><br></pre></td></tr></table></figure>
<p>但是对于不支持 <code>Date.now()</code> 方法的浏览器（如 IE8-），我们还可以使用+操作符把 Date 对象转换成字符串，也可以达到同样的目的，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 记录开始时间</span><br><span class="line">var start = +new Date();</span><br><span class="line"></span><br><span class="line">// 这里运行一段代码</span><br><span class="line">doSomething();</span><br><span class="line"></span><br><span class="line">// 记录结束时间</span><br><span class="line">var stop = +new Date();</span><br><span class="line"></span><br><span class="line">// 得到代码运行时间</span><br><span class="line">var timeUse = start - stop;</span><br></pre></td></tr></table></figure>
<h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><h3 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a>Getter</h3><ul>
<li><code>getFullYear()</code>：根据本地时间返回指定日期对象的年份（四位数年份时返回四位数字）</li>
<li><code>getMonth()</code>：根据本地时间返回指定日期对象的月份（0-11）</li>
<li><code>getDate()</code>：根据本地时间返回指定日期对象的月份中的第几天（1-31）</li>
<li><code>getDay()</code>：根据本地时间返回指定日期对象的星期中的第几天（0-6）</li>
<li><code>getHours()</code>：根据本地时间返回指定日期对象的小时（0-23）</li>
<li><code>getMinutes()</code>：根据本地时间返回指定日期对象的分钟（0-59）</li>
<li><code>getSeconds()</code>：根据本地时间返回指定日期对象的秒数（0-59）</li>
<li><code>getMilliseconds()</code>：根据本地时间返回指定日期对象的微秒（0-999）</li>
<li><code>getTime()</code>：返回从1970-1-1 00:00:00 UTC（协调世界时）到该日期经过的毫秒数，对于1970-1-1 00:00:00 UTC之前的时间返回负值。</li>
</ul>
<p>下面我们以一个简单的格式化时间来说明下上面方法的一些使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 将时间格式化为：YYYY-MM-DD HH:mm:ss</span><br><span class="line"></span><br><span class="line">// 小于或等于9的数字前面添加0</span><br><span class="line">function addZero(num) &#123;</span><br><span class="line">    return num &gt; 9 ? num : &apos;0&apos; + num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 格式化时间，可传入一个时间或使用当前时间</span><br><span class="line">function dateFormat(date) &#123;</span><br><span class="line">    var date = date ? new Date(date) : new Date();</span><br><span class="line">    var str = date.getFullYear() + &apos;-&apos; + addZero(date.getMonth() + 1) + &apos;-&apos; + addZero(date.getDate()) + &apos; &apos; + addZero(date.getHours()) + &apos;:&apos; + addZero(date.getMinutes()) + &apos;:&apos; + addZero(date.getSeconds());</span><br><span class="line"></span><br><span class="line">    return str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dateFormat(); // 2017-08-07 17:44:51</span><br><span class="line">dateFormat(1502095046000); // 2017-08-07 16:37:26</span><br><span class="line">dateFormat(&apos;December 3, 1995 03:19:05&apos;); // 1995-12-03 03:19:05</span><br></pre></td></tr></table></figure>
<p>当然对于格式化时间这么常用的功能，已经有<a href="http://momentjs.cn/" target="_blank" rel="noopener">Moment.js</a>库来帮我们处理了。</p>
<h3 id="Setter"><a href="#Setter" class="headerlink" title="Setter"></a>Setter</h3><ul>
<li><code>setFullYear()</code>：根据本地时间为指定日期对象设置完整年份（四位数年份是四个数字）</li>
<li><code>setMonth()</code>：根据本地时间为指定日期对象设置月份</li>
<li><code>setDate()</code>：根据本地时间为指定的日期对象设置月份中的第几天</li>
<li><code>setHours()</code>：根据本地时间为指定日期对象设置小时数</li>
<li><code>setMinutes()</code>：根据本地时间为指定日期对象设置分钟数</li>
<li><code>setSeconds()</code>：根据本地时间为指定日期对象设置秒数</li>
<li><code>setMilliseconds()</code>：根据本地时间为指定日期对象设置毫秒数</li>
<li><code>setTime()</code>：通过指定从 1970-1-1 00:00:00 UTC 开始经过的毫秒数来设置日期对象的时间，对于早于 1970-1-1 00:00:00 UTC的时间可使用负值。</li>
</ul>
<p>对于该系列的方法，我们经常用于倒计时，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 2017 年 IMWebconf 大会开始时间为： 2017-09-16 09:30:00</span><br><span class="line">// 计算大会时间的倒计时</span><br><span class="line"></span><br><span class="line">var nowTime = Date.now(); // 1502189810994，这个时间会变动</span><br><span class="line"></span><br><span class="line">var confDate = new Date(2017, 8, 16, 9, 30, 0),</span><br><span class="line">    confTime = confDate.getTime(); // 1505525400000</span><br><span class="line"></span><br><span class="line">var diffTime = parseInt((confTime - nowTime) / 1000);</span><br><span class="line"></span><br><span class="line">if(diffTime &gt; 0) &#123;</span><br><span class="line">    var days = parseInt(diffTime / (60 * 60 * 24)); // 得到剩余天数</span><br><span class="line">    var hours = parseInt((diffTime % (60 * 60 * 24)) / (60 * 60)); // 得到剩余小时</span><br><span class="line">    var minutes = parseInt(((diffTime % (60 * 60 * 24)) % (60 * 60)) / 60); // 得到剩余分钟</span><br><span class="line">    var seconds = ((diffTime % (60 * 60 * 24)) % (60 * 60)) % 60; // 得到剩余秒</span><br><span class="line">    // 距离大会还剩38天14:33:9，依赖于 nowTime 为 1502189810994 的计算</span><br><span class="line">    console.log(&apos;距离大会还剩&apos; + days + &apos;天&apos; + hours + &apos;:&apos; + minutes + &apos;:&apos; + seconds);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    console.log(&apos;大会已经圆满结束，敬请期待下一次大会！&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样对于倒计时，也有很多库可用：<a href="http://www.cnblogs.com/lhb25/archive/2012/12/05/12-essential-countdown-timer-scripts.html" target="_blank" rel="noopener">分享12个效果精美的 JavaScript 倒计时脚本</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date" target="_blank" rel="noopener">Date | MDN</a></li>
<li><a href="http://javascript.ruanyifeng.com/stdlib/date.html" target="_blank" rel="noopener">Date对象</a></li>
</ul>
<h1 id="业务中如何计算白屏和首屏时间"><a href="#业务中如何计算白屏和首屏时间" class="headerlink" title="业务中如何计算白屏和首屏时间"></a>业务中如何计算白屏和首屏时间</h1><p>白屏时间和首屏时间是我们衡量网站加载性能的两个重要指标。在开发中，我们需要根据业务页面的具体情况，相应地统计页面白屏时间和首屏时间。对于白屏时间和首屏时间，计算的原理是不变的，但计算的的方式可能会根据页面情况有所改变，因此大家需要具体问题具体分析。</p>
<h2 id="白屏时间"><a href="#白屏时间" class="headerlink" title="白屏时间"></a>白屏时间</h2><p><strong>白屏时间</strong>指的是浏览器开始显示内容的时间。因此我们只需要知道是浏览器开始显示内容的时间点，即页面白屏结束时间点即可获取到页面的白屏时间。</p>
<p><img src="/2019/01/25/前端知识归纳（6）-性能与工程化（part2-性能）/firstpaint.png" alt="firstpaint.png"><br>通过<a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#Painting" target="_blank" rel="noopener">浏览器工作原理</a>，我们可以知道：</p>
<ul>
<li>浏览器在加载页面的刚开始，页面是处于空白的状态，只有当页面发生绘制操作时会开始显示内容。</li>
<li>浏览器加载页面是一个渐进的过程。为达到更好的用户体验，呈现引擎会力求尽快将内容显示在屏幕上。它不必等到整个 HTML 文档解析完毕之后，就会开始构建呈现树和设置布局。在不断接收页面内容的同时，呈现引擎会将部分内容解析并显示出来。</li>
<li>非可视化的 DOM 元素不会显示到窗口中，例如 <code>&lt;head&gt;</code>，这就意味着浏览器在绘制之前，至少需要先解析完head元素中的内容。</li>
</ul>
<h2 id="计算白屏时间"><a href="#计算白屏时间" class="headerlink" title="计算白屏时间"></a>计算白屏时间</h2><p>因此，我们通常认为浏览器开始渲染 <code>&lt;body&gt;</code> 标签或者解析完 <code>&lt;head&gt;</code> 标签的时刻就是页面白屏结束的时间点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;白屏&lt;/title&gt;</span><br><span class="line">  &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    // 不兼容performance.timing 的浏览器，如IE8</span><br><span class="line">    window.pageStartTime = Date.now();</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">  &lt;!-- 页面 CSS 资源 --&gt;</span><br><span class="line">  &lt;link rel=&quot;stylesheet&quot; href=&quot;common.css&quot;&gt;</span><br><span class="line">  &lt;link rel=&quot;stylesheet&quot; href=&quot;page.css&quot;&gt;</span><br><span class="line">  &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    // 白屏时间结束点</span><br><span class="line">    window.firstPaint = Date.now();</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;!-- 页面内容 --&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>因此白屏时间则可以这样计算出：</p>
<h3 id="可使用-Performance-API-时"><a href="#可使用-Performance-API-时" class="headerlink" title="可使用 Performance API 时"></a>可使用 Performance API 时</h3><p><code>白屏时间 = firstPaint - performance.timing.navigationStart;</code></p>
<h3 id="不可使用-Performance-API-时"><a href="#不可使用-Performance-API-时" class="headerlink" title="不可使用 Performance API 时"></a>不可使用 Performance API 时</h3><p><code>白屏时间 = firstPaint - pageStartTime;</code></p>
<h2 id="首屏时间"><a href="#首屏时间" class="headerlink" title="首屏时间"></a>首屏时间</h2><p><strong>首屏时间</strong>是指用户打开网站开始，到浏览器首屏内容渲染完成的时间。对于用户体验来说，首屏时间是用户对一个网站的重要体验因素。通常一个网站，如果首屏时间在5秒以内是比较优秀的，10秒以内是可以接受的，10秒以上就不可容忍了。超过10秒的首屏时间用户会选择刷新页面或立刻离开。</p>
<p><img src="/2019/01/25/前端知识归纳（6）-性能与工程化（part2-性能）/firstscreen.png" alt="firstscreen.png"></p>
<h2 id="计算首屏时间"><a href="#计算首屏时间" class="headerlink" title="计算首屏时间"></a>计算首屏时间</h2><p>明白了<strong>首屏时间</strong>的概念后，我们计算首屏时间则更加清晰了。现实中，不同业务的首屏内容并不是一样的。因此计算首屏时间，需要根据业务页面情况，相应地选择计算首屏时间的方法。</p>
<p>通常计算首屏的方法有</p>
<ul>
<li>首屏模块标签标记法</li>
<li>统计首屏内加载最慢的图片的时间</li>
<li>自定义首屏内容计算法</li>
</ul>
<h3 id="1、首屏模块标签标记法"><a href="#1、首屏模块标签标记法" class="headerlink" title="1、首屏模块标签标记法"></a>1、首屏模块标签标记法</h3><p><strong>首屏模块标签标记法</strong>，通常适用于首屏内容不需要通过拉取数据才能生存以及页面不考虑图片等资源加载的情况。我们会在 HTML 文档中对应首屏内容的标签结束位置，使用内联的 JavaScript 代码记录当前时间戳。如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;首屏&lt;/title&gt;</span><br><span class="line">  &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    window.pageStartTime = Date.now();</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">  &lt;link rel=&quot;stylesheet&quot; href=&quot;common.css&quot;&gt;</span><br><span class="line">  &lt;link rel=&quot;stylesheet&quot; href=&quot;page.css&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;!-- 首屏可见模块1 --&gt;</span><br><span class="line">  &lt;div class=&quot;module-1&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;!-- 首屏可见模块2 --&gt;</span><br><span class="line">  &lt;div class=&quot;module-2&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    window.firstScreen = Date.now();</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">  &lt;!-- 首屏不可见模块3 --&gt;</span><br><span class="line">  &lt;div class=&quot;module-3&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;!-- 首屏不可见模块4 --&gt;</span><br><span class="line">  &lt;div class=&quot;module-4&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>此时<strong>首屏时间</strong>等于 <code>firstScreen - performance.timing.navigationStart;</code></p>
<p>事实上<strong>首屏模块标签标记法</strong> 在业务中的情况比较少，大多数页面都需要通过接口拉取数据才能完整展示，因此我们会使用 JavaScript 脚本来判断首屏页面内容加载情况。</p>
<h3 id="2、统计首屏内图片完成加载的时间"><a href="#2、统计首屏内图片完成加载的时间" class="headerlink" title="2、统计首屏内图片完成加载的时间"></a>2、统计首屏内图片完成加载的时间</h3><p>通常我们首屏内容加载最慢的就是图片资源，因此我们会把<strong>首屏内加载最慢的图片的时间</strong>当做首屏的时间。</p>
<p>由于浏览器对每个页面的 TCP 连接数有限制，使得并不是所有图片都能立刻开始下载和显示。因此我们在 DOM树 构建完成后将会去遍历首屏内的所有图片标签，并且监听所有图片标签 onload 事件，最终遍历图片标签的加载时间的最大值，并用这个最大值减去 <code>navigationStart</code> 即可获得近似的首屏时间。</p>
<p>此时<strong>首屏时间</strong>等于 <code>加载最慢的图片的时间点 - performance.timing.navigationStart;</code></p>
<h3 id="3、自定义模块内容计算法"><a href="#3、自定义模块内容计算法" class="headerlink" title="3、自定义模块内容计算法"></a>3、自定义模块内容计算法</h3><p>由于<strong>统计首屏内图片完成加载的时间</strong>比较复杂。因此我们在业务中通常会通过自定义模块内容，来简化计算首屏时间。如下面的做法：</p>
<ul>
<li>忽略图片等资源加载情况，只考虑页面主要 DOM</li>
<li>只考虑首屏的主要模块，而不是严格意义首屏线以上的所有内容</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对于首屏时间和白屏时间，业界并没有一个统一的计算标准。<strong>大家不能通过死记硬背来实现首屏时间和白屏时间的统计，而应该根据首屏时间和白屏时间的具体原理，切合自身业务情况来制定统计的方法。统计首屏时间和白屏时间是为了让我们能够更明白我们业务页面的情况，而不是为了统计而去统计。</strong></p>
<h2 id="更多阅读-1"><a href="#更多阅读-1" class="headerlink" title="更多阅读"></a>更多阅读</h2><ul>
<li><a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#Painting" target="_blank" rel="noopener">浏览器的工作原理</a></li>
</ul>
<h1 id="优化性能的三大主要手段"><a href="#优化性能的三大主要手段" class="headerlink" title="优化性能的三大主要手段"></a>优化性能的三大主要手段</h1><ul>
<li>减少请求文件数</li>
<li>减少资源体积</li>
<li>提高网络传输</li>
</ul>
<h1 id="CDN-相关"><a href="#CDN-相关" class="headerlink" title="CDN 相关"></a>CDN 相关</h1><p>为了提高网页应用的加载速度，我们会使用到浏览器缓存，然而浏览器缓存只能提升二次访问的速度。对于加速首次访问的速度，我们最常见的手段则是使用 CDN 加速。</p>
<p>CDN 的全称是 <strong>Content Delivery Network</strong>，即内容分发网络。通过将静态资源缓存到离用户很近的相同网络运营商的 CDN 节点上，使用户可以就近取得所需的内容，解决网络拥塞状况，提高用户访问网站的响应速度。</p>
<p><img src="/2019/01/25/前端知识归纳（6）-性能与工程化（part2-性能）/cdn.png" alt="cdn.png"></p>
<p>事实上，在一些较大型的公司来说，通常是由公司的运维开发人员来负责部署 CDN 服务的，前端人员只需要了解使用 CDN 服务的大致流程即可。</p>
<h2 id="1-选择-CDN-供应商"><a href="#1-选择-CDN-供应商" class="headerlink" title="1 选择 CDN 供应商"></a>1 选择 CDN 供应商</h2><p>事实上，现在还有许多的 CDN 服务厂家，我们需要根据需求的情况去选择相应的厂商。现阶段 CDN 云服务商的竞争已经由 <strong>技术</strong> 逐渐取代<strong>价格</strong>成为 CDN 厂商在客户谈判时最关键因素，技术更高的 CDN 服务能够降低带宽成本、提升用户体验。</p>
<p>如今 CDN 各大厂商都会提供十分详尽的接入文档，使我们接入的开发成本变得更低。这里列举国内比较出名的 CDN 厂商：</p>
<ul>
<li><a href="https://www.upyun.com/products/cdn?gclid=EAIaIQobChMImayU6ejE1QIVHL69Ch19bANOEAAYAyAAEgLGY_D_BwE" target="_blank" rel="noopener">叉拍云</a></li>
<li><a href="https://cloud.tencent.com/product/cdn?fromSource=gwzcw.251481.251481.251481&amp;gclid=EAIaIQobChMIpLnk7eHE1QIVVQoqCh3JhwO3EAAYAiAAEgKBJ_D_BwE" target="_blank" rel="noopener">腾讯云</a></li>
<li><a href="https://www.qiniu.com/products/fusion?utm_campaign=googleSEM&amp;utm_source=googleSEM&amp;utm_medium=googleSEM&amp;utm_content=googleSEM&amp;gclid=EAIaIQobChMIpLnk7eHE1QIVVQoqCh3JhwO3EAAYASAAEgIDpvD_BwE" target="_blank" rel="noopener">七牛云</a></li>
<li><a href="https://www.alibabacloud.com/zh?utm_content=se_712562&amp;gclid=EAIaIQobChMIiI7yienE1QIVjgYqCh1RPgD_EAAYASAAEgJRwfD_BwE" target="_blank" rel="noopener">阿里云</a></li>
</ul>
<h2 id="2-连接-CDN-服务"><a href="#2-连接-CDN-服务" class="headerlink" title="2 连接 CDN 服务"></a>2 连接 CDN 服务</h2><p>通常购买了 CDN 服务后，该 CDN 服务会提供相应的接口让我们去上传和部署我们的资源。这部分的工作通常是由我们运维人员去负责的，对于一些小公司可能则需要前端或者后台人员去负责连接 CDN 服务，使业务能够部署静态资源到相应的服务器上。</p>
<h2 id="3-前端工程静态资源部署"><a href="#3-前端工程静态资源部署" class="headerlink" title="3 前端工程静态资源部署"></a>3 前端工程静态资源部署</h2><p>使用 CDN 服务，对前端工程产生了一定的影响，我们需要对静态资源的部署做两项改变：</p>
<h3 id="3-1-将静态资源部署到不同网络线路的服务器中"><a href="#3-1-将静态资源部署到不同网络线路的服务器中" class="headerlink" title="3.1 将静态资源部署到不同网络线路的服务器中"></a>3.1 将静态资源部署到不同网络线路的服务器中</h3><p>由于用户的网络线路有很多种，如网通、电信、移动等，为了让不同地区的用户会访问到离自己最近的相同网络线路上的 CDN 节点。因此我们需要将我们的资源部署到不同的网络线路的服务器中，然后通过这些服务器同步到不同线路的 CDN 节点上。</p>
<h3 id="3-2-加载静态资源时需使用与页面不同的域名"><a href="#3-2-加载静态资源时需使用与页面不同的域名" class="headerlink" title="3.2 加载静态资源时需使用与页面不同的域名"></a>3.2 加载静态资源时需使用与页面不同的域名</h3><p>使用不同的域名来加载 CDN 服务的静态资源，一方面便于接入为 CDN 时设置 DNS 的智能解析。另一方面当静态资源和主页面使用不同的域名，在加载静态资源时 HTTP 请求并不会带上主域页面的 Cookie 等数据，减少了请求时的数据传输量，进一步加快网络访问。</p>
<h3 id="3-3-资源路径的修正"><a href="#3-3-资源路径的修正" class="headerlink" title="3.3 资源路径的修正"></a>3.3 资源路径的修正</h3><p>通常情况下，我们的资源都是在本地，比如有个 JS 文件，我们在 HTML 里面按照相对目录引用它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;js/script.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>使用了 CDN 的话，资源都部署到了 CDN 服务器上去咯，这个时候我们必须用绝对路径来引用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;http://xxx.xxx.xxx/js/script.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>所有啊，必须有个修正资源路径的过程，而这个过程当然不能手动，通常都是在工程化里面解决这个问题。</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>如今 CDN 服务基本上已经成为现代大型网页应用的标配。这项技术是一种十分常用的网络性能优化手段。在未来的前端开发中，我们会经常与 CDN 打交道。因此如果能够清楚了解了 CDN 服务的相关原理和概念，将会让我们在将来的开发中能够更加得心应手。</p>
<h2 id="更多阅读-2"><a href="#更多阅读-2" class="headerlink" title="更多阅读"></a>更多阅读</h2><ul>
<li><a href="https://yusi123.com/3093.html" target="_blank" rel="noopener">盘点国内网站常用的一些CDN公共库加速服务</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/23/前端知识归纳（6）-性能与工程化（part1-网络通路简介）/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sponge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sponge的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/23/前端知识归纳（6）-性能与工程化（part1-网络通路简介）/" itemprop="url">前端知识归纳（6）-- 性能与工程化（part1 网络通路简介）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-23T10:17:30+08:00">
                2019-01-23
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/01/23/前端知识归纳（6）-性能与工程化（part1-网络通路简介）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/01/23/前端知识归纳（6）-性能与工程化（part1-网络通路简介）/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  718
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  2
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="从输入地址到返回请求"><a href="#从输入地址到返回请求" class="headerlink" title="从输入地址到返回请求"></a>从输入地址到返回请求</h1><p><img src="/2019/01/23/前端知识归纳（6）-性能与工程化（part1-网络通路简介）/performance.png" alt="performance.png"></p>
<h1 id="网络体系结构"><a href="#网络体系结构" class="headerlink" title="网络体系结构"></a>网络体系结构</h1><p><img src="/2019/01/23/前端知识归纳（6）-性能与工程化（part1-网络通路简介）/network.png" alt="network.png"></p>
<h1 id="TCP-Transmission-Control-Protocol"><a href="#TCP-Transmission-Control-Protocol" class="headerlink" title="TCP(Transmission Control Protocol)"></a>TCP(Transmission Control Protocol)</h1><p>传输控制协议，一种面向连接的、可靠地、基于字节流的传输层通信协议。<br><img src="/2019/01/23/前端知识归纳（6）-性能与工程化（part1-网络通路简介）/三次握手.png" alt="三次握手.png"></p>
<h1 id="HTTP-HyperText-Transfer-Protocol"><a href="#HTTP-HyperText-Transfer-Protocol" class="headerlink" title="HTTP(HyperText Transfer Protocol)"></a>HTTP(HyperText Transfer Protocol)</h1><p>超文本传输协议，一种用于分布式、协作式和超媒体信息系统的应用层协议。</p>
<h2 id="客户端发起"><a href="#客户端发起" class="headerlink" title="客户端发起"></a>客户端发起</h2><p><img src="/2019/01/23/前端知识归纳（6）-性能与工程化（part1-网络通路简介）/报文.png" alt="报文.png"></p>
<h2 id="服务器端返回"><a href="#服务器端返回" class="headerlink" title="服务器端返回"></a>服务器端返回</h2><p><img src="/2019/01/23/前端知识归纳（6）-性能与工程化（part1-网络通路简介）/报文1.png" alt="报文1.png"></p>
<h1 id="常见的状态码"><a href="#常见的状态码" class="headerlink" title="常见的状态码"></a>常见的状态码</h1><p>HTTP 有 <code>request</code> 和 <code>response</code>，他们都有自己的报文结构：</p>
<p><img src="/2019/01/23/前端知识归纳（6）-性能与工程化（part1-网络通路简介）/报文2.jpg" alt="报文2.jpg"><br>其中 <code>response</code> 有很多不同的状态码，这里呢就聊聊常见的状态码。</p>
<h2 id="404"><a href="#404" class="headerlink" title="404"></a>404</h2><p>404 的含义就是客户端所访问的资源不存在，可以试试这个<a href="http://codeing.imweb.io/hhhh" target="_blank" rel="noopener">链接</a>。</p>
<p>值得说说的就是，服务器当然可以侦测到 404 的请求，从而返回一些好玩的页面，比如腾讯新闻网的找寻失联儿童，<a href="http://www.qq.com/babygohome/?pgv_ref=404" target="_blank" rel="noopener">点这里瞧瞧</a>。</p>
<h2 id="304"><a href="#304" class="headerlink" title="304"></a>304</h2><p>这个是面试官常问的状态码，因为涉及到浏览器的缓存，当然，这个在我们的“浏览器缓存”相关的视频里面有详细的讲解，这里不多说。</p>
<h2 id="301-和-302"><a href="#301-和-302" class="headerlink" title="301 和 302"></a>301 和 302</h2><p>同样是面试官常问的问题。</p>
<p>这两个都表示跳转了，区别是啥呢？</p>
<p>你有一个博客，运营了一段时间，首页链接假设是 <code>http://blog.com/index.html</code> 。</p>
<p>后来呢，你换了个域名，链接就变成了 <code>http://superblog.com/index.html</code> 。</p>
<p>现在问题来了，你的很多迷弟迷妹都只知道老首页的链接呀，你肯定希望他们访问你的老首页就跳转到新首页对不对，所以这个时候跳转的需求登场了！</p>
<p>你有两个选择：</p>
<ul>
<li>301 ，这个表示永久移动，就是你再也不会用老域名了，所有能识别 301 语义的客户端啊，请收藏我的新链接！</li>
<li>302 ，表示临时移动，就是你还会用回老域名，现在临时切下，所有能识别 302 语义的客户端，请继续收藏我的老链接！</li>
</ul>
<p>以上，就是 301 和 302 ，搞清楚哦。</p>
<h2 id="500"><a href="#500" class="headerlink" title="500"></a>500</h2><p>前端工程师的大敌，500 ！</p>
<p>调式接口的时候碰到 500 的话，你就可光明正大地操起折叠凳怼过去了！</p>
<p>哈哈哈，让 500 来的更多点吧，衰仔！</p>
<p>当然，上面都是常见的、好玩的状态码，更多的没意思的状态码可以参考下其他资料哈。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="http://www.runoob.com/http/http-status-codes.html" target="_blank" rel="noopener">HTTP 状态码</a></li>
</ul>
<h1 id="浏览器缓存相关的头字段"><a href="#浏览器缓存相关的头字段" class="headerlink" title="浏览器缓存相关的头字段"></a>浏览器缓存相关的头字段</h1><table>
<thead>
<tr>
<th>服务器返回</th>
<th>浏览器发送</th>
</tr>
</thead>
<tbody>
<tr>
<td>Last-Modified</td>
<td>If-Modified-Since</td>
</tr>
<tr>
<td>ETag</td>
<td>If-None-Match</td>
</tr>
<tr>
<td>Expires</td>
<td>Cache-Control</td>
</tr>
</tbody>
</table>
<p>Expires会存在一个问题，当服务器与客户端时间相差很大，它设置的失效时间不能如预期那样进行。</p>
<p><img src="/2019/01/23/前端知识归纳（6）-性能与工程化（part1-网络通路简介）/缓存.png" alt="缓存.png"></p>
<h1 id="DNS-Domain-Name-System"><a href="#DNS-Domain-Name-System" class="headerlink" title="DNS(Domain Name System)"></a>DNS(Domain Name System)</h1><p>域名系统 应用层协议<br>域名从右到左 顶级域名-&gt;二级域名-&gt;三级域名-&gt;四级域名</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/21/前端知识归纳（5）-JS进阶（part4-canvas进阶）/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sponge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sponge的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/21/前端知识归纳（5）-JS进阶（part4-canvas进阶）/" itemprop="url">前端知识归纳（5）-- JS进阶（part4 canvas进阶）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-21T15:56:29+08:00">
                2019-01-21
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/01/21/前端知识归纳（5）-JS进阶（part4-canvas进阶）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/01/21/前端知识归纳（5）-JS进阶（part4-canvas进阶）/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3.4k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  13
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="键盘事件处理"><a href="#键盘事件处理" class="headerlink" title="键盘事件处理"></a>键盘事件处理</h1><p>在制作 PC 端的游戏的时候，我们经常需要监听键盘的事件，以便响应用户的键盘操作。目前，对键盘事件的支持主要遵循的是 <code>DOM0级</code>。</p>
<h2 id="按键相关事件"><a href="#按键相关事件" class="headerlink" title="按键相关事件"></a>按键相关事件</h2><p>键盘操作涉及下面三种事件：</p>
<ul>
<li><strong>keydown</strong>：当用户按下键盘上的任意键时触发，而且如果按住按住不放的话，会重复触发此事件。</li>
<li><strong>keypress</strong>：当用户按下键盘上的字符键时触发，而且如果按住不放的，会重复触发此事件（按下Esc键也会触发这个事件）。</li>
<li><strong>keyup</strong>：当用户释放键盘上的键时触发。</li>
</ul>
<h2 id="按键过程"><a href="#按键过程" class="headerlink" title="按键过程"></a>按键过程</h2><p>用户按下键盘上的字符键时</p>
<ul>
<li>首先会触发 <code>keydown</code> 事件</li>
<li>然后紧接着触发 <code>keypress</code> 事件</li>
<li>最后触发 <code>keyup</code>事件<br>如果用户按下了一个字符键不放，就会重复触发 <code>keydown</code> 和 <code>keypress</code> 事件，直到用户松开该键为止。</li>
</ul>
<h2 id="键码（keyCode）对照表"><a href="#键码（keyCode）对照表" class="headerlink" title="键码（keyCode）对照表"></a>键码（keyCode）对照表</h2><p>在发送 <code>keydown</code> 和 <code>keyup</code> 事件时，<code>event</code> 对象的 <code>keyCode</code> 属性中会包含一个代码，与键盘上一个特定的键对应。如下图，为我们键盘键位的 keyCode 对照表：</p>
<p><img src="/2019/01/21/前端知识归纳（5）-JS进阶（part4-canvas进阶）/keycode.png" alt="keycode.png"></p>
<h2 id="例子：简单实现键盘控制物体移动"><a href="#例子：简单实现键盘控制物体移动" class="headerlink" title="例子：简单实现键盘控制物体移动"></a>例子：简单实现键盘控制物体移动</h2><p>实现的基本原理如下：监听全局键盘操作事件，当用户按下某一按键时，返回对应的键值，然后再根据键值判断用户按下了哪一按键，来控制物体上下移动的操作，效果如下：</p>
<p><img src="/2019/01/21/前端知识归纳（5）-JS进阶（part4-canvas进阶）/keyboard.gif" alt="keyboard.gif"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;物体移动&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;canvas id=&quot;canvas&quot; width=&quot;500&quot; height=&quot;500&quot;&gt;&lt;/canvas&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">      var canvas = document.getElementById(&apos;canvas&apos;);</span><br><span class="line">      var context = canvas.getContext(&apos;2d&apos;);</span><br><span class="line">      var rect = &#123;</span><br><span class="line">        x: 100, // 矩形的 x 坐标</span><br><span class="line">        y: 400, // 矩形的 y 坐标</span><br><span class="line">        width: 100, // 矩形的宽度</span><br><span class="line">        height: 100, // 矩形的高度</span><br><span class="line">        step: 30 // 矩形移动的步伐</span><br><span class="line">      &#125;</span><br><span class="line">      // 全局监听键盘操作的 keydown 事件 </span><br><span class="line">      document.onkeydown = function(e) &#123;  </span><br><span class="line">        // 获取被按下的键值 (兼容写法)</span><br><span class="line">        var key = e.keyCode || e.which || e.charCode;</span><br><span class="line">        switch(key) &#123;</span><br><span class="line">          // 点击左方向键</span><br><span class="line">          case 37: </span><br><span class="line">            rect.x -= 20;</span><br><span class="line">            drawRect();</span><br><span class="line">            break;</span><br><span class="line">          // 点击上方向键</span><br><span class="line">          case 38: </span><br><span class="line">            rect.y -= 20;</span><br><span class="line">            drawRect();</span><br><span class="line">            break;</span><br><span class="line">          // 点击右方向键</span><br><span class="line">          case 39: </span><br><span class="line">            rect.x += 20;</span><br><span class="line">            drawRect();</span><br><span class="line">            break;</span><br><span class="line">          // 点击下方向键</span><br><span class="line">          case 40: </span><br><span class="line">            rect.y += 20;</span><br><span class="line">            drawRect();</span><br><span class="line">            break;</span><br><span class="line">        &#125; </span><br><span class="line">      &#125;;</span><br><span class="line">      function drawRect() &#123;</span><br><span class="line">        // 清除画布</span><br><span class="line">        context.clearRect(0, 0, canvas.width, canvas.height);</span><br><span class="line">        // 绘制矩形</span><br><span class="line">        context.fillRect(rect.x, rect.y, rect.width, rect.height);</span><br><span class="line">      &#125;</span><br><span class="line">      // 第一次绘制</span><br><span class="line">      drawRect();</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h1 id="碰撞检测"><a href="#碰撞检测" class="headerlink" title="碰撞检测"></a>碰撞检测</h1><p>在实现 Canvas 游戏和动画中，往往需要解决物体相互碰撞的情况如。对于物体碰撞相关的问题，我们会在动画中采用 <code>碰撞检测</code> 来解决，以此实现更为逼真的动画。</p>
<h2 id="碰撞检测关键步骤"><a href="#碰撞检测关键步骤" class="headerlink" title="碰撞检测关键步骤"></a>碰撞检测关键步骤</h2><p>碰撞检测需要处理经历下面两个关键的步骤：</p>
<ul>
<li>计算判断两个物体是否发生碰撞</li>
<li>发生碰撞后，两个物体的状态和动画效果的处理</li>
</ul>
<h2 id="计算碰撞"><a href="#计算碰撞" class="headerlink" title="计算碰撞"></a>计算碰撞</h2><p>只要两个物体相互接触，它们就会发生碰撞。</p>
<h3 id="矩形物体碰撞检测"><a href="#矩形物体碰撞检测" class="headerlink" title="矩形物体碰撞检测"></a>矩形物体碰撞检测</h3><p>假设检测发生碰撞的物体是 <strong>矩形1</strong> 和 <strong>矩形2</strong> 时，我们只需检测 <strong>矩形1</strong> 的上下左右四侧的和 <strong>矩形2</strong> 是否存在着距离。我们可以看看下面的图：</p>
<p><img src="/2019/01/21/前端知识归纳（5）-JS进阶（part4-canvas进阶）/crash-rect.png" alt="crash-rect.png"></p>
<p>我们可以看到 <strong>矩形2</strong> 和 <strong>矩形1</strong> 之间没有发生碰撞共有四种可能的情况：</p>
<ul>
<li><strong>矩形2</strong>的右侧 离 <strong>矩形1</strong>的左侧有一段距离</li>
<li><strong>矩形2</strong>的左侧 离 <strong>矩形1</strong>的右侧有一段距离</li>
<li><strong>矩形2</strong>的底部 离 <strong>矩形1</strong>的顶部有一段距离</li>
<li><strong>矩形2</strong>的顶部 离 <strong>矩形1</strong>的底部有一段距离</li>
</ul>
<p>当符合上面其中一种情况，则两个矩形没有发生碰撞。</p>
<p>因此通过逆向推导我们可以得出：<code>当上面四种情况都不满足的时候，则代表两个矩形碰撞了</code>。在代码中，我们可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 判断四边是否都没有空隙</span><br><span class="line">if (!(rect2.x + rect2.width &lt; rect1.x) &amp;&amp;</span><br><span class="line">    !(rect1.x + rect1.width &lt; rect2.x) &amp;&amp;</span><br><span class="line">    !(rect2.y + rect2.height &lt; rect1.y) &amp;&amp;</span><br><span class="line">    !(rect1.y + rect1.height &lt; rect2.y)) &#123;</span><br><span class="line">    // 物体碰撞了</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="圆形物体碰撞检测"><a href="#圆形物体碰撞检测" class="headerlink" title="圆形物体碰撞检测"></a>圆形物体碰撞检测</h3><p>假设发生碰撞的物体是 <code>圆形</code> 时，检测碰撞则变得比较复杂了，前面矩形所使用的碰撞检测，并不能判断圆形物体的情况。如下图的情况：</p>
<p><img src="/2019/01/21/前端知识归纳（5）-JS进阶（part4-canvas进阶）/crash-circle.png" alt="crash-circle.png"></p>
<p>那么如何检测两圆是否碰撞了呢？这个时候又到了考验我们数理化的知识了。</p>
<p>检测两圆是否相交：<code>当两个圆心之间的距离是否小于两个圆的半径之和</code>。这是已经被证实的数学运算。如下图所示：</p>
<p><img src="/2019/01/21/前端知识归纳（5）-JS进阶（part4-canvas进阶）/crash-distance.png" alt="crash-distance.png"></p>
<p>其中 <code>dx</code> 和 <code>dy</code> 分别表示两个圆之间的横坐标和纵坐标的差值。 即 <code>dx = x2 - x1;</code> <code>dy = y2 - y1;</code></p>
<p>然后我们需要通过 <code>勾股定理</code> 计算两个圆心之间的距离。如下图：</p>
<p><img src="/2019/01/21/前端知识归纳（5）-JS进阶（part4-canvas进阶）/crash-gougu.png" alt="crash-gougu.png"></p>
<p>因此我们碰撞检测的代码可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var dx = circle2.x - circle1.x;</span><br><span class="line">var dy = circle2.y - circle1.y;</span><br><span class="line">var distance = Math.sqrt((dx * dx) + (dy * dy));</span><br><span class="line">if (distance &lt; circle1.radius + circle2.radius) &#123;</span><br><span class="line">  // 两个圆形碰撞了</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面讲解了怎么检测矩形和圆形是否碰撞，基本已经可以适用大部分场景。对于特殊的场景，则需要大家自己去思考如何检测了。</p>
<h3 id="碰撞后的处理"><a href="#碰撞后的处理" class="headerlink" title="碰撞后的处理"></a>碰撞后的处理</h3><p>当检测到碰撞后，则可以对碰撞的物体进行状态设置了，可以是相互毁灭，或者是反弹等。这里大家可以根据场景来决定。</p>
<h1 id="canvas参考"><a href="#canvas参考" class="headerlink" title="canvas参考"></a>canvas参考</h1><h2 id="更多知识点"><a href="#更多知识点" class="headerlink" title="更多知识点"></a>更多知识点</h2><p>这里列出 Canvas 其他的知识点，感兴趣同学们可以深入了解下。</p>
<ul>
<li><a href="https://www.w3cplus.com/canvas/canvas-states.html" target="_blank" rel="noopener">保存和恢复绘画状态(save 和 store)</a></li>
<li><a href="https://www.w3cplus.com/canvas/gradient.html" target="_blank" rel="noopener">渐变</a></li>
<li><a href="https://oxcow.gitbooks.io/h5-canvas-study-notes/content/chapter6_shadows.html" target="_blank" rel="noopener">阴影</a></li>
<li><a href="https://oxcow.gitbooks.io/h5-canvas-study-notes/content/chapter3_transform_func.html" target="_blank" rel="noopener">变形</a></li>
<li><a href="https://www.w3cplus.com/canvas/compositing.html" target="_blank" rel="noopener">合成</a></li>
<li><a href="http://www.w3school.com.cn/tags/canvas_getimagedata.asp" target="_blank" rel="noopener">导出画布（getImageData）</a></li>
<li><a href="http://www.cnblogs.com/chyingp/archive/2012/12/01/canvas_pixel_api.html" target="_blank" rel="noopener">像素处理常用接口</a></li>
</ul>
<h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><p>下面是一些推荐的 Canvas 学习书籍。</p>
<p><strong>《HTML5 CANVAS基础教程》</strong><br>十分适合新手看的一本 canvas 书籍。</p>
<p><img src="/2019/01/21/前端知识归纳（5）-JS进阶（part4-canvas进阶）/canvas-end-book1.png" alt="canvas-end-book1.png"></p>
<p><strong>《HTML5 canvas开发详解》</strong></p>
<p>是一本大而全的 canvas 书籍，覆盖的知识点比较多。如果希望全面了解 canvas 的可以看一下。</p>
<p><img src="/2019/01/21/前端知识归纳（5）-JS进阶（part4-canvas进阶）/canvas-end-book2.png" alt="canvas-end-book2.png"><br>下面是一些推荐的学习 Canvas 的教程文章</p>
<ul>
<li><a href="https://www.w3cplus.com/blog/tags/604.html" target="_blank" rel="noopener">Canvas 入门精通教程</a></li>
<li><a href="https://oxcow.gitbooks.io/h5-canvas-study-notes/content/chapter6_shadows.html" target="_blank" rel="noopener">HTML5 Canvas 学习笔记</a></li>
<li><a href="https://wohugb.gitbooks.io/javascript/content/htmlapi/canvas.html" target="_blank" rel="noopener">Canvas API-阮一峰</a></li>
</ul>
<h1 id="图像裁剪"><a href="#图像裁剪" class="headerlink" title="图像裁剪"></a>图像裁剪</h1><p>前面我们讲到如何在 Canvas 中加载各种帅气酷炫的图像。但是有时候我们并不需要使用完整的图像，而只是图像的一部分内容，这个时候我们就需要使用<code>图像裁剪</code>。<code>图像裁剪</code>是图片 PS 中经常使用到的一种技术，目的是为了突出我们图片的某个特定的区域。接下来，让我们学习如何使用 Canvas 来裁剪我们的图像。</p>
<h2 id="还是-context-drawImage"><a href="#还是-context-drawImage" class="headerlink" title="还是 context.drawImage()"></a>还是 context.drawImage()</h2><p>没错，你没看错，我们还是使用 <code>drawImage</code> 的方法。裁剪是 <code>drawImage</code> 方法的最后一种用法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.drawImage(image, source_x, source_y, source_width, source_height, x, y, width, heigh);</span><br></pre></td></tr></table></figure>
<p>它总共涉及9个参数，具体如下：</p>
<ul>
<li><strong>image</strong>：源图像对象</li>
<li><strong>source_x</strong>：源图像的裁剪区原点横坐标</li>
<li><strong>source_y</strong>：源图像的裁剪区原点纵坐标</li>
<li><strong>source_width</strong>：源图像的裁剪区宽度</li>
<li><strong>source_height</strong>：源图像的裁剪区高度</li>
<li><strong>x</strong>：在画布上绘制图像的原点横坐标</li>
<li><strong>y</strong>：在画布上绘制图像的原点纵坐标</li>
<li><strong>width</strong>：在画布上绘制图像的宽度</li>
<li><strong>heigh</strong>：在画布上绘制图像的高度</li>
</ul>
<p>上面所有参数的看起来可能比较抽象，可以通过结合下面说明图进行理解：</p>
<p><img src="/2019/01/21/前端知识归纳（5）-JS进阶（part4-canvas进阶）/canvas-drawimage.png" alt="canvas-drawimage.png"></p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>接下来让我们尝试截取图片的中间部分，如下图：</p>
<p><img src="/2019/01/21/前端知识归纳（5）-JS进阶（part4-canvas进阶）/canvas-drawimage-demo.png" alt="canvas-drawimage-demo.png"><br>相关代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;物体移动&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;canvas id=&quot;canvas&quot; width=&quot;500&quot; height=&quot;500&quot;&gt;&lt;/canvas&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">      var canvas = document.getElementById(&apos;canvas&apos;);</span><br><span class="line">      var context = canvas.getContext(&apos;2d&apos;);</span><br><span class="line"></span><br><span class="line">      var image = new Image();</span><br><span class="line">      image.src = &apos;http://coding.imweb.io/img/p3/retina-pixel.jpg&apos;;</span><br><span class="line">      image.onload = function () &#123;</span><br><span class="line">        // 加载图片后，边截取图片且缩放展示在画布左上角</span><br><span class="line">        context.drawImage(image, 260, 260, 480, 480, 0, 0, 240, 240);</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h1 id="requestAnimationFrame"><a href="#requestAnimationFrame" class="headerlink" title="requestAnimationFrame"></a>requestAnimationFrame</h1><h2 id="动画原理简介"><a href="#动画原理简介" class="headerlink" title="动画原理简介"></a>动画原理简介</h2><p>动画的基本原理是依靠人类具有视觉暂留的特性人的眼睛看到一幅画或一个物体后，在 1/24 秒内不会消失（即每秒钟至少更换24张画面）。利用这一原理，在一幅画（一帧）还没消失前播放下一幅画（下一帧），就会给人造成流畅的视觉变化效果。</p>
<p>如下面的翻书动画，就是利用我们人的视觉暂留的特性的。</p>
<p><img src="/2019/01/21/前端知识归纳（5）-JS进阶（part4-canvas进阶）/animation.gif" alt="animation.gif"><br>因此我们可以得出：<strong>如果我们需要实现动画，只需要设置定时不断地绘制下一帧的画面便可以了</strong>。</p>
<h2 id="早期动画循环"><a href="#早期动画循环" class="headerlink" title="早期动画循环"></a>早期动画循环</h2><p>在 <code>JavaScript</code> 中我们可以使用 <code>setTimeout</code> 和 <code>setInterval</code> 来设置延时任务。<br>因此在很长时间以来，计时器一直都是 <code>JavaScript 动画</code>的最核心技术。如下面的代码就是使用 <code>setTimeout</code> 方法来实现基本的动画循环：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function animate() &#123;</span><br><span class="line">    // 动画内容</span><br><span class="line">    animation1();</span><br><span class="line">    animation2();</span><br><span class="line">    // 间隔100ms执行动画循环</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        animate();</span><br><span class="line">    &#125;, 100);</span><br><span class="line">&#125;</span><br><span class="line">// 执行动画</span><br><span class="line">animate();</span><br></pre></td></tr></table></figure>
<h2 id="循环间隔-60Hz"><a href="#循环间隔-60Hz" class="headerlink" title="循环间隔 60Hz"></a>循环间隔 60Hz</h2><p>早期的动画循环时候，最关键的问题是确定循环间隔的时长。一方面，循环间隔必须足够短，这样才能动画效果显得更平滑流畅；另一方面，循环时隔还要足够长，这样才能确保浏览器有能力渲染产生的变化。我们知道大多数的显示器的刷新频率是 60Hz ，即相当于在每秒钟中屏幕会重绘 60 次。因此最平滑动画的最佳循环间隔是 <code>1000ms/60</code>，约等于 16.7ms。</p>
<h2 id="setTimeout-和-setInterval-问题"><a href="#setTimeout-和-setInterval-问题" class="headerlink" title="setTimeout 和 setInterval 问题"></a>setTimeout 和 setInterval 问题</h2><p>然后无论是 <code>setTimeout</code> 和 <code>setInterval</code> 都并不是十分精准。</p>
<p>我们知道 <code>JavaScript</code> 是一个单线程的解释器，在一定时间能只能执行一段代码。为了要控制代码的执行顺序，就需要通过一个 <code>JavaScript任务队列</code> 来进行管理控制（任务会按照添加到队列的顺序执行）。通过 <code>setTimeout</code> 和 <code>setInterval</code> 我们能够设置延时多长时间把我们的代码任务添加到 <code>JavaScript任务队列</code> 中。如果当前任务队列是空的，那么添加的代码可以立即执行；如果队列不是空的，则新添加的任务需要等到其前面所有的任务都执行完成才能执行。由于前面的任务到底需要多少时间执行完，是不确定的，所以没有办法保证，<code>setTimeout</code> 和 <code>setInterval</code> 指定的任务，一定会按照预定时间执行。</p>
<p>如下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(animateTask, 1000 / 60);</span><br><span class="line">// 耗时长的任务</span><br><span class="line">longTimeTask();</span><br></pre></td></tr></table></figure>
<p>上面代码的 <code>setTimeout</code>，我们制定 16.7ms 后运行 <code>animateTask</code> 任务。但是，如果由于后面的 <code>longTimeTask</code> 执行（当前脚本的同步任务））非常耗时，即使过了 16.7ms 仍无法结束，那么延迟执行的 <code>animateTask</code> 就只有等着，只有等到前面的任务都运行完，才能轮到它执行。</p>
<p>具体可阅读下 John Resig（jQuery 作者）的这篇文章 <a href="https://johnresig.com/blog/how-javascript-timers-work/" target="_blank" rel="noopener">How JavaScript Timers Work</a>。</p>
<h2 id="requestAnimationFrame-1"><a href="#requestAnimationFrame-1" class="headerlink" title="requestAnimationFrame"></a>requestAnimationFrame</h2><p>由于 <code>setTimeout</code> 和 <code>setInterval</code> 的不精准问题，促使了 <code>requestAnimationFrame</code> 的诞生。 <code>requestAnimationFrame</code> 是专门为实现高性能的帧动画而设计的一个API，目前已在多个浏览器得到了支持，你可以把它用在 DOM 上的效果切换或者 Canvas 画布动画中。 <code>requestAnimationFrame</code> 并不是定时器，但和 <code>setTimeout</code> 很相似，在没有 <code>requestAnimationFrame</code> 的浏览器一般都是用setTimeout模拟。 <code>requestAnimationFrame</code> 跟屏幕刷新同步（大多数是 60Hz ）。如果浏览器支持 <code>requestAnimationFrame</code> , 则不建议使用 <code>setTimeout</code> 来做动画。</p>
<h2 id="requestAnimationFrame-的兼容使用"><a href="#requestAnimationFrame-的兼容使用" class="headerlink" title="requestAnimationFrame 的兼容使用"></a>requestAnimationFrame 的兼容使用</h2><p>下面是我们常规使用 <code>requestAnimationFrame</code> 的兼容写法，当浏览器不兼容的 <code>requestAnimationFrame</code> 时则通过使用 <code>setTimeout</code> 来模拟实现,且设定渲染间隔为 <code>1000ms/60</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 判断是否有 requestAnimationFrame 方法，如果有则模拟实现</span><br><span class="line">window.requestAnimFrame =</span><br><span class="line">window.requestAnimationFrame ||</span><br><span class="line">window.webkitRequestAnimationFrame ||</span><br><span class="line">window.mozRequestAnimationFrame ||</span><br><span class="line">window.oRequestAnimationFrame ||</span><br><span class="line">window.msRequestAnimationFrame ||</span><br><span class="line">function(callback) &#123;</span><br><span class="line">    window.setTimeout(callback, 1000 / 30);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="使用-requestAnimationFrame-实现动画"><a href="#使用-requestAnimationFrame-实现动画" class="headerlink" title="使用 requestAnimationFrame 实现动画"></a>使用 requestAnimationFrame 实现动画</h2><p>下面我们将使用 requestAnimationFrame 来实现一个物体来回移动的动画。效果如下：</p>
<p><img src="/2019/01/21/前端知识归纳（5）-JS进阶（part4-canvas进阶）/requestAnimationFrame.gif" alt="requestAnimationFrame.gif"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;认识Canvas&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;canvas id=&quot;canvas&quot; width=&quot;500&quot; height=&quot;500&quot; style=&quot;border: 1px solid #33&quot;&gt;&lt;/canvas&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var canvas = document.getElementById(&apos;canvas&apos;);</span><br><span class="line">        var context = canvas.getContext(&apos;2d&apos;);</span><br><span class="line">        // 兼容定义 requestAnimFrame</span><br><span class="line">        window.requestAnimFrame =</span><br><span class="line">        window.requestAnimationFrame ||</span><br><span class="line">        window.webkitRequestAnimationFrame ||</span><br><span class="line">        window.mozRequestAnimationFrame ||</span><br><span class="line">        window.oRequestAnimationFrame ||</span><br><span class="line">        window.msRequestAnimationFrame ||</span><br><span class="line">        function(callback) &#123;</span><br><span class="line">            window.setTimeout(callback, 1000 / 30);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        // 绘制的圆的对象</span><br><span class="line">        var circle = &#123;</span><br><span class="line">            x: 250,</span><br><span class="line">            y: 250,</span><br><span class="line">            radius: 50,</span><br><span class="line">            direction: &apos;right&apos;,</span><br><span class="line">            // 移动圆形</span><br><span class="line">            move: function() &#123;</span><br><span class="line">                if (this.direction === &apos;right&apos;) &#123;</span><br><span class="line">                    if (this.x &lt;= 430) &#123;</span><br><span class="line">                         this.x += 5;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        this.direction = &apos;left&apos;;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    if (this.x &gt;= 60) &#123;</span><br><span class="line">                         this.x -= 5;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        this.direction = &apos;right&apos;;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            draw: function() &#123;</span><br><span class="line">                // 绘制圆形</span><br><span class="line">                context.beginPath();</span><br><span class="line">                // 设置开始角度为0，结束角度为 2π 弧度</span><br><span class="line">                context.arc(this.x, this.y, this.radius, 0, 2 * Math.PI, false);</span><br><span class="line">                context.fillStyle = &apos;#00c09b&apos;;</span><br><span class="line">                context.fill();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 动画执行函数</span><br><span class="line">        function animate() &#123;</span><br><span class="line">            // 随机更新圆形位置</span><br><span class="line">            circle.move();</span><br><span class="line">            // 清除画布</span><br><span class="line">            context.clearRect(0, 0, canvas.width, canvas.height);</span><br><span class="line">            // 绘画圆</span><br><span class="line">            circle.draw();</span><br><span class="line">            // 使用requestAnimationFrame实现动画循环</span><br><span class="line">            requestAnimationFrame(animate);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 先画第一帧的圆，即初始化的圆</span><br><span class="line">        circle.draw();</span><br><span class="line">        // 执行animate</span><br><span class="line">        animate();        </span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/21/前端知识归纳（5）-JS进阶（part3-canvas入门）/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sponge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sponge的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/21/前端知识归纳（5）-JS进阶（part3-canvas入门）/" itemprop="url">前端知识归纳（5）-- JS进阶（part3 canvas入门）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-21T15:38:39+08:00">
                2019-01-21
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/01/21/前端知识归纳（5）-JS进阶（part3-canvas入门）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/01/21/前端知识归纳（5）-JS进阶（part3-canvas入门）/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  859
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  3
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="绘制圆弧"><a href="#绘制圆弧" class="headerlink" title="绘制圆弧"></a>绘制圆弧</h1><p>前面给大家讲解了怎么绘制矩形和线条，接下来将讲解下如何在 canvas 画布上 <code>绘制圆弧和圆形</code>。</p>
<p>相对矩形来说，绘制圆弧则更为复杂。绘制圆弧需要确定圆心的坐标，圆弧的角度以及绘制圆弧的绘制方法等等。</p>
<h2 id="context-arc"><a href="#context-arc" class="headerlink" title="context.arc()"></a>context.arc()</h2><p>在 Canvas 中我们可以使用 <code>context.arc()</code> 的方法来创建圆弧路径。简单来说，在 Canvas 中，创建一条圆弧路径是从与<code>圆心(x, y)</code>距离为一个<code>半径</code>且角度为<code>开始角度</code>的位置开始，最后停在离<code>圆心(x, y)</code>距离为一个<code>半径</code>且角度为<code>结束角度</code>的位置上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.arc(x, y, radius, startAngle, endAngle, anticlockwise);</span><br></pre></td></tr></table></figure>
<p><strong>参数说明：</strong></p>
<p><img src="/2019/01/21/前端知识归纳（5）-JS进阶（part3-canvas入门）/canvas-arc.png" alt="canvas-arc.png"></p>
<ul>
<li><code>x</code>: 圆的中心的 x 坐标</li>
<li><code>y</code>: 圆的中心的 y 坐标</li>
<li><code>radius</code>: 圆的半径</li>
<li><code>startAngle</code>: 圆弧的开始角度</li>
<li><code>endAngle</code>: 圆弧的结束角度</li>
<li><code>anticlockwise</code>: 可选的参数，规定应该逆时针还是顺时针绘图，默认值为 false</li>
</ul>
<h2 id="弧度表示角度"><a href="#弧度表示角度" class="headerlink" title="弧度表示角度"></a>弧度表示角度</h2><p>这里需要注意的是，在 Canvas 中表示圆弧的开始角度和结束角度都是以弧度来表示的，而不是使用角度来表示。</p>
<p>举个例子: <strong>360度使用弧度来表示则是 2π (pi 的两倍) 弧度</strong>。</p>
<p><img src="/2019/01/21/前端知识归纳（5）-JS进阶（part3-canvas入门）/canvas-degree.png" alt="canvas-degree.png"></p>
<p>我们可以通过下面的公式进行换算。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var degree = 1; // 表示 1°</span><br><span class="line">var radians = degree * (Math.PI / 180); // 0.0175弧度</span><br></pre></td></tr></table></figure>
<h2 id="绘制圆弧路径"><a href="#绘制圆弧路径" class="headerlink" title="绘制圆弧路径"></a>绘制圆弧路径</h2><p>接下来让我们尝试绘制一个圆弧，如下图：</p>
<p><img src="/2019/01/21/前端知识归纳（5）-JS进阶（part3-canvas入门）/canvas-arc1.png" alt="canvas-arc1.png"></p>
<p>具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 开始创建新路径</span><br><span class="line">context.beginPath();</span><br><span class="line">// 创建一个半圆圆弧</span><br><span class="line">context.arc(250, 250, 200, 0, Math.PI, false);</span><br><span class="line">// 调用 stroke 绘制该路径</span><br><span class="line">context.stroke();</span><br></pre></td></tr></table></figure>
<h2 id="绘制部分圆"><a href="#绘制部分圆" class="headerlink" title="绘制部分圆"></a>绘制部分圆</h2><p>接下来让我们尝试绘制一个部分圆形填充图形，如下图：</p>
<p><img src="/2019/01/21/前端知识归纳（5）-JS进阶（part3-canvas入门）/canvas-arc2.png" alt="canvas-arc2.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 开始创建新路径</span><br><span class="line">context.beginPath();</span><br><span class="line">// 创建一个圆弧</span><br><span class="line">context.arc(250, 250, 200, 0, 0.75 * Math.PI, false);</span><br><span class="line">// 填充该圆弧</span><br><span class="line">context.fill();</span><br></pre></td></tr></table></figure>
<h2 id="绘制圆形"><a href="#绘制圆形" class="headerlink" title="绘制圆形"></a>绘制圆形</h2><p><code>圆形</code>实际上是由<code>圆弧</code>组成（首尾相连的圆弧便是圆形）,如果我们需要绘制下面的圆形：</p>
<p><img src="/2019/01/21/前端知识归纳（5）-JS进阶（part3-canvas入门）/canvas-arc3.png" alt="canvas-arc3.png"></p>
<p>具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 开始创建新路径</span><br><span class="line">context.beginPath();</span><br><span class="line">// 设置开始角度为0，结束角度为 2π 弧度</span><br><span class="line">context.arc(250, 250, 200, 0, 2 * Math.PI, false);</span><br><span class="line">// 使用 fill 自动闭合圆弧路径，然后填充圆弧区域</span><br><span class="line">context.fill();</span><br></pre></td></tr></table></figure>
<h2 id="绘制圆角矩形"><a href="#绘制圆角矩形" class="headerlink" title="绘制圆角矩形"></a>绘制圆角矩形</h2><p>我们不仅可以使用 <code>context.arc()</code> 来绘制圆弧和圆形，我们还可以来绘制圆角矩形上的圆角。如下图为我们需要绘制一个圆角矩形：</p>
<p><img src="/2019/01/21/前端知识归纳（5）-JS进阶（part3-canvas入门）/canvas-arc4.png" alt="canvas-arc4.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var x = 120; // 圆角矩形左上角横坐标</span><br><span class="line">var y = 120; // 圆角矩形左上角纵坐标</span><br><span class="line">var width = 250; // 圆角矩形的宽度</span><br><span class="line">var height = 250; // 圆角矩形的高度</span><br><span class="line">var radius = 50; // 圆角的半径</span><br><span class="line"></span><br><span class="line">// 开始创建新路径</span><br><span class="line">context.beginPath();</span><br><span class="line">// 绘制左上角圆角</span><br><span class="line">context.arc(x + radius, y + radius, radius, Math.PI, Math.PI * 3 / 2);</span><br><span class="line">// 绘制顶边路径</span><br><span class="line">context.lineTo(width - radius + x, y);</span><br><span class="line">// 绘制右上角圆角</span><br><span class="line">context.arc(width - radius + x, radius + y, radius, Math.PI * 3 / 2, Math.PI * 2);</span><br><span class="line">// 绘制右边路径</span><br><span class="line">context.lineTo(width + x, height + y - radius);</span><br><span class="line">// 绘制右下角圆角</span><br><span class="line">context.arc(width - radius + x, height - radius + y, radius, 0, Math.PI * 1 / 2);</span><br><span class="line">// 绘制底边路径</span><br><span class="line">context.lineTo(radius + x, height +y);</span><br><span class="line">// 绘制左下角圆角</span><br><span class="line">context.arc(radius + x, height - radius + y, radius, Math.PI * 1 / 2, Math.PI);</span><br><span class="line">// 闭合路径 也可使用 context.lineTo(x, y + radius);</span><br><span class="line">context.closePath();</span><br><span class="line">// 设置绘制的颜色</span><br><span class="line">context.strokeStyle = &apos;#188eee&apos;;</span><br><span class="line">context.stroke();</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/21/前端知识归纳（5）-JS进阶（part2-继承）/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sponge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sponge的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/21/前端知识归纳（5）-JS进阶（part2-继承）/" itemprop="url">前端知识归纳（5）-- JS进阶（part2 继承）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-21T14:17:41+08:00">
                2019-01-21
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/01/21/前端知识归纳（5）-JS进阶（part2-继承）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/01/21/前端知识归纳（5）-JS进阶（part2-继承）/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  835
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  3
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>继承可以使子类具有父类的属性和方法，而不需要重复编写相同的代码。<br><img src="/2019/01/21/前端知识归纳（5）-JS进阶（part2-继承）/inherit.png" alt="inherit.png"></p>
<h1 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h1><p><img src="/2019/01/21/前端知识归纳（5）-JS进阶（part2-继承）/inherit-1.png" alt="inherit-1.png"><br><img src="/2019/01/21/前端知识归纳（5）-JS进阶（part2-继承）/inherit-2.png" alt="inherit-2.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Person 构造函数</span><br><span class="line"> */</span><br><span class="line">function Person() &#123;</span><br><span class="line">    this.isPerson = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.sayHello = function() &#123;</span><br><span class="line">    console.log(&apos;Hello!&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Student(grade) &#123;</span><br><span class="line">    this.grade = grade;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student.prototype = new Person(); // 打通原型链</span><br><span class="line"></span><br><span class="line">Student.prototype.sayGrade = function() &#123;</span><br><span class="line">    console.log(&apos;I am Grade &apos; + this.grade);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var student = new Student(4);</span><br><span class="line">console.log(student.isPerson); // true</span><br><span class="line">student.sayHello(); // &apos;Hello!&apos;</span><br><span class="line">console.log(student.grade);  // 4</span><br><span class="line">student.sayGrade(); // &apos;I am Grade 4&apos;;</span><br></pre></td></tr></table></figure>
<p>原型链继承的不足：</p>
<ul>
<li><p>constructor 子类的constructor指向父类的constructor<br>可以通过修改子类的constructor指向来修复这个问题。<br><img src="/2019/01/21/前端知识归纳（5）-JS进阶（part2-继承）/inherit-3.png" alt="inherit-3.png"><br><img src="/2019/01/21/前端知识归纳（5）-JS进阶（part2-继承）/inherit-4.png" alt="inherit-4.png"></p>
</li>
<li><p>属性共享问题<br>当父类的属性是object、array类型时，子类之间会相互影响。<br><img src="/2019/01/21/前端知识归纳（5）-JS进阶（part2-继承）/inherit-5.png" alt="inherit-5.png"></p>
</li>
<li><p>参数<br>父类参数固定，子类无法去修改<br><img src="/2019/01/21/前端知识归纳（5）-JS进阶（part2-继承）/inherit-6.png" alt="inherit-6.png"></p>
</li>
</ul>
<h1 id="使用构造函数继承"><a href="#使用构造函数继承" class="headerlink" title="使用构造函数继承"></a>使用构造函数继承</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Person 构造函数</span><br><span class="line"> */</span><br><span class="line">function Person(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayHello = function() &#123; // 继承不到</span><br><span class="line">    console.log(&apos;Hi! I am &apos; + this.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Student(name, grade) &#123;</span><br><span class="line">    Person.call(this, name, grade);</span><br><span class="line">    this.grade = grade;</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype.selfIntroduce = function() &#123;</span><br><span class="line">    console.log(`My name is $&#123;this.name&#125;. I am Grade $&#123;this.grade&#125;`);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var student = new Student(&apos;Kevin&apos;, 4);</span><br><span class="line">console.log(student.name);  // Kevin</span><br><span class="line">console.log(student.grade); // 4</span><br><span class="line">student.selfIntroduce(); // &apos;My name is Kevin. I am Grade 4&apos;;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/01/21/前端知识归纳（5）-JS进阶（part2-继承）/inherit-7.png" alt="inherit-7.png"><br>构造函数继承的不足：父类原型链上的方法都无法继承得到。</p>
<h1 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h1><p><img src="/2019/01/21/前端知识归纳（5）-JS进阶（part2-继承）/inherit-8.png" alt="inherit-8.png"><br>组合继承的不足<br>调用了两次父类的构造函数，父类的属性冗余。<br><img src="/2019/01/21/前端知识归纳（5）-JS进阶（part2-继承）/inherit-9.png" alt="inherit-9.png"></p>
<h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><p><img src="/2019/01/21/前端知识归纳（5）-JS进阶（part2-继承）/inherit-10.png" alt="inherit-10.png"></p>
<h1 id="ES6-的继承"><a href="#ES6-的继承" class="headerlink" title="ES6 的继承"></a>ES6 的继承</h1><p>到目前为止，我们已经知道了 JS 中继承方式的最佳实践了，相信大家会有这样的疑惑：怎么感觉 JS 继承方式这么绕，又要借用构造函数，又要自己封装继承原型的函数。没错，你们的感觉是对的，大家也是这么觉得的，以至于后来有了很多 JS 继承的封装或者语法糖，比如现在比较火的 <a href="https://www.typescriptlang.org/" target="_blank" rel="noopener"><code>TypeScript</code></a> 就是参照经典的面向对象对 JS 的类的声明和继承进行了封装。</p>
<p>幸运的是，ES6 标准已经将 经典的 <code>class</code> 声明类和继承的方式纳入标准了，前面经典的面向对象扩展资料中就有提到 ES6 中怎么声明类了，下面是使用 ES6 实现 <code>Person</code> 类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//定义类</span><br><span class="line">class Person &#123;</span><br><span class="line">    // 构造函数</span><br><span class="line">    constructor(name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 方法</span><br><span class="line">    sayName() &#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 ES6 中继承是通过 <code>extends</code> 关键字声明的，比如下面 <code>Student</code> 类继承了 <code>Person</code> 类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//定义类</span><br><span class="line">class Student extends Person &#123;</span><br><span class="line">    // 构造函数</span><br><span class="line">    constructor(name, grade) &#123;</span><br><span class="line">        super(name);</span><br><span class="line">        this.grade = grade;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 方法</span><br><span class="line">    sayGrade() &#123;</span><br><span class="line">        console.log(`I am Grade $&#123;this.grade&#125;`);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面继承方式关键点其实就2个，一个是通过 <code>extends</code> 关键字声明继承关系，第二是在子类构造函数 <code>constructor</code> 中调用 <code>super</code> 函数，这其实就相当于我们的借用构造函数。要注意的点是 <code>constructor</code> 中 <code>this</code> 对象要 <code>super</code> 调用之后使用，不然会报错。具体原因可以看下面参考资料。</p>
<p>目前部分现代浏览器新版本已经实现对 ES6 中的 <code>class</code> 和继承的支持，但是注意在旧版本或者 IE 浏览器中是不支持的，所以使用的时候要注意，或者配合使用 <a href="https://babeljs.io/" target="_blank" rel="noopener">Babel</a> 等编译工具。</p>
<hr>
<ul>
<li><a href="http://es6.ruanyifeng.com/#docs/class-extends" target="_blank" rel="noopener">Class 的继承</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/18/前端知识归纳（5）-JS进阶（part1-创建对象）/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sponge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sponge的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/18/前端知识归纳（5）-JS进阶（part1-创建对象）/" itemprop="url">前端知识归纳（5）-- JS进阶（part1 创建对象）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-18T17:14:19+08:00">
                2019-01-18
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/01/18/前端知识归纳（5）-JS进阶（part1-创建对象）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/01/18/前端知识归纳（5）-JS进阶（part1-创建对象）/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.2k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  4
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function createBottle(name, price, isKeepWram) &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        name: name,</span><br><span class="line">        price: price,</span><br><span class="line">        isKeepWarm: isKeepWarm</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var bottle = create(&apos;太空杯&apos;, 49, false);</span><br></pre></td></tr></table></figure>
<p>缺陷：证明实例与对象间的关系困难。</p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数的方法"><a href="#函数的方法" class="headerlink" title="函数的方法"></a>函数的方法</h2><p>修改函数的执行环境</p>
<ul>
<li><code>bind(thisArg)</code></li>
<li><code>call(thisArg, arg1, arg2, ...)</code></li>
<li><code>apply(thisArg, [arg1, arg2, ...])</code></li>
</ul>
<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age, sex) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.sex = sex;</span><br><span class="line">    this.sayHello = function() &#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person = new Person(&apos;Sponge&apos;, 2, &apos;male&apos;);</span><br><span class="line">console.log(person instanceof Person); // true</span><br></pre></td></tr></table></figure>
<p>优点：实例由对象构造，且每个实例都有自己的属性和方法。<br>不足之处：重复声明相同的函数，浪费内存</p>
<h1 id="原型-prototype"><a href="#原型-prototype" class="headerlink" title="原型 prototype"></a>原型 prototype</h1><p>原型是函数的一个属性，是一个对象<br>如果函数作为构造函数使用，那么这个构造函数的所有实例，都共享这个原型对象</p>
<ul>
<li>constructor 指向该实例的构造函数</li>
<li>isPrototypeOf() 判断实例的原型</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Person () &#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.name = &apos;Jonny&apos;;</span><br><span class="line">Person.prototype.friends = [&apos;Cover&apos;, &apos;Kevin&apos;];</span><br><span class="line">Person.prototype.sayHello = function() &#123;</span><br><span class="line">    console.log(&apos;hello&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person1 = new Person(&apos;Sugar&apos;);</span><br><span class="line">var person2 = new Person(&apos;Cream&apos;);</span><br><span class="line">console.log(person1.friends);  // [&apos;Cover&apos;, &apos;Kevin&apos;]</span><br><span class="line">console.log(person2.friends);  // [&apos;Cover&apos;, &apos;Kevin&apos;]</span><br><span class="line">console.log(person1.sayHello === person2.sayHello); // true</span><br></pre></td></tr></table></figure>
<p>优点：不重复声明相同的函数，节省内存。<br>缺点：每个实例的属性、方法都一样，当试图去修改一个实例的属性为object、array类型的时候，各个实例之间的属性会相互影响。</p>
<h1 id="构造函数结合原型"><a href="#构造函数结合原型" class="headerlink" title="构造函数结合原型"></a>构造函数结合原型</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, friends) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.friends = friends;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.sayHello = function() &#123;</span><br><span class="line">    console.log(&apos;hello&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person1 = new Person(&apos;Sugar&apos;, [&apos;milk&apos;, &apos;fruit&apos;]);</span><br><span class="line">var person2 = new Person(&apos;Cream&apos;, [&apos;Bread&apos;, &apos;egg&apos;]);</span><br><span class="line">console.log(person1.name);  // Sugar</span><br><span class="line">console.log(person2.name);  // Cream</span><br><span class="line">console.log(person1.friends);  // [&apos;milk&apos;, &apos;fruit&apos;]</span><br><span class="line">console.log(person2.friends);  // [&apos;Bread&apos;, &apos;egg&apos;]</span><br><span class="line">console.log(person1.sayHello === person2.sayHello); // true</span><br></pre></td></tr></table></figure>
<p>最终的解决方法：各个实例各自的属性通过构造函数生成，实现个性化，而实例的共同方法则挂在prototype上，节约内存。</p>
<h1 id="经典的面向对象"><a href="#经典的面向对象" class="headerlink" title="经典的面向对象"></a>经典的面向对象</h1><p>这里所说的“经典的面向对象”，是有“类”这个概念的面向对象，比如 <code>Java</code> ，它就有“类”的概念。有接触过 <code>Java</code> 的同学很容易就能理解，没有接触过 <code>Java</code> 的同学也不要慌，我这就来说说。</p>
<p>面向对象这个概念，实在是太像我们的世界。</p>
<p>说道“人”，Person ，大家肯定是想到一个鼻子，两个眼睛，是一个宽泛的概念，可以让你想到任何人。</p>
<p>所以“人”，是一个抽象，它描述一个特定<strong>类</strong>别的东西，一<strong>类</strong>动物。</p>
<p>“动物”也是一<strong>类</strong>抽象，从字面意思理解，“动物”是能动的生物，和“植物”区分开来。</p>
<p>人是动物，你我是人，也是动物。</p>
<p>但是，“你我”又有区别，虽然都是人，但我叫 <code>jero</code> ，你叫刘德华，我很帅，你却更帅。在“人”这个大的<strong>类</strong>别下，你我是两个不同的实体，两个不同的对象，你我都是具象化的人，是一个具体的概念。</p>
<p>看到了吗，<strong>类</strong>这个字眼都加粗了，因为这是面向对象的一个重要概念。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    constructor(legs) &#123;</span><br><span class="line">        this.legs = 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(new Animal(2)); // &#123; legs: 2 &#125;</span><br></pre></td></tr></table></figure>
<p>上面就是 <code>Animal class</code> 了，非常的简单，也很抽象，但是，我们 <code>new</code> 了一下之后，就具体化了，我们 <code>new</code> 了一个两条腿的动物。</p>
<p>好吧，我想大家还是更容易接受人的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    constructor(name) &#123;</span><br><span class="line">        this.legs = 2;</span><br><span class="line">       this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(new Person(&apos;刘德华&apos;)); // &#123; legs: 2 &#125;</span><br></pre></td></tr></table></figure>
<p>上面就是 <code>Person class</code> 咯，<code>Person</code> 只是抽象，对吧，但是我们给他一个名字“刘德华”，他就是活生生的人咯，这就是实例化。</p>
<p>“类”是抽象，其实这个“类”就是分门别“类”里的“类”。“对象”和“实例”，现在如果你们区分不了，可以混用，就是“类”实例化的产物。</p>
<p>好咯，再看代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Person(name) &#123; // 这个 Person 就是类</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.legs = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(new Person(&apos;刘德华&apos;)); // 活生生的人，就是实例</span><br></pre></td></tr></table></figure>
<p>虽然 JS 里面没有类的概念，但我们还是习惯叫“类”，而且不同的“类”有时候是有关系的，比如“人”是“动物”，这个时候，“人”就是子类，“动物”就是父类，也挺容易理解。</p>
<p>好吧，就讲到这，不理解的同学，多想想就行。</p>
<p>最后说一句，上面的 <code>class Person</code> 代码，也是 JS 代码，ES6 新增了类的语法，创建对象更容易了，大家可以看看。</p>
<hr>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="noopener">类</a></li>
<li><a href="http://es6.ruanyifeng.com/#docs/class" target="_blank" rel="noopener">Class 的基本语法</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/18/前端知识归纳（4）-JS基础（part5-JQuery）/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sponge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sponge的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/18/前端知识归纳（4）-JS基础（part5-JQuery）/" itemprop="url">前端知识归纳（4）-- JS基础（part5 JQuery）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-18T16:41:33+08:00">
                2019-01-18
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/01/18/前端知识归纳（4）-JS基础（part5-JQuery）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/01/18/前端知识归纳（4）-JS基础（part5-JQuery）/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.1k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  4
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="简单教程"><a href="#简单教程" class="headerlink" title="简单教程"></a>简单教程</h1><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><p><img src="/2019/01/18/前端知识归纳（4）-JS基础（part5-JQuery）/jquery-1.png" alt="jquery-1.png"></p>
<p><img src="/2019/01/18/前端知识归纳（4）-JS基础（part5-JQuery）/jquery-2.png" alt="jquery-2.png"></p>
<p><img src="/2019/01/18/前端知识归纳（4）-JS基础（part5-JQuery）/jquery-3.png" alt="jquery-3.png"></p>
<p><img src="/2019/01/18/前端知识归纳（4）-JS基础（part5-JQuery）/jquery-4.png" alt="jquery-4.png"></p>
<p><img src="/2019/01/18/前端知识归纳（4）-JS基础（part5-JQuery）/jquery-5.png" alt="jquery-5.png"></p>
<h2 id="遍历DOM"><a href="#遍历DOM" class="headerlink" title="遍历DOM"></a>遍历DOM</h2><p><img src="/2019/01/18/前端知识归纳（4）-JS基础（part5-JQuery）/jquery-6.png" alt="jquery-6.png"></p>
<p><img src="/2019/01/18/前端知识归纳（4）-JS基础（part5-JQuery）/jquery-7.png" alt="jquery-7.png"></p>
<p><img src="/2019/01/18/前端知识归纳（4）-JS基础（part5-JQuery）/jquery-8.png" alt="jquery-8.png"></p>
<h2 id="添加和删除DOM元素"><a href="#添加和删除DOM元素" class="headerlink" title="添加和删除DOM元素"></a>添加和删除DOM元素</h2><p><img src="/2019/01/18/前端知识归纳（4）-JS基础（part5-JQuery）/jquery-9.png" alt="jquery-9.png"></p>
<p><img src="/2019/01/18/前端知识归纳（4）-JS基础（part5-JQuery）/jquery-10.png" alt="jquery-10.png"></p>
<h2 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h2><p><img src="/2019/01/18/前端知识归纳（4）-JS基础（part5-JQuery）/jquery-11.png" alt="jquery-11.png"></p>
<p><img src="/2019/01/18/前端知识归纳（4）-JS基础（part5-JQuery）/jquery-12.png" alt="jquery-12.png"></p>
<p><img src="/2019/01/18/前端知识归纳（4）-JS基础（part5-JQuery）/jquery-13.png" alt="jquery-13.png"></p>
<p><img src="/2019/01/18/前端知识归纳（4）-JS基础（part5-JQuery）/jquery-14.png" alt="jquery-14.png"></p>
<h1 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h1><p>一般来说我们要给某个元素绑定事件，都会直接绑定在该元素上，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 给 li 元素绑定点击事件</span><br><span class="line">$(&apos;li&apos;).click(function() &#123;</span><br><span class="line">    console.log(&apos;你点击我了&apos;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>但是这种直接的处理会有以下问题：</p>
<ul>
<li>通过 JS 新添加的 li 元素并没有该事件绑定，所以点击无效</li>
<li>元素如果比较多的话，比喻有200个 li ，那每个 li 都绑定一个事件，性能是非常低的</li>
</ul>
<p>那么如何解决这些问题呢？这就是我们要说的事件委托（或叫事件代理）。</p>
<p>事件委托简单来说就是利用事件冒泡，只指定一个事件处理程序，用来管理某一类型的所有事件。</p>
<p>以一个 todo list 为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 要点击的元素是 todo-item</span><br><span class="line">// 但是我们把事件绑定在父元素 todo-list 上，实现事件委托</span><br><span class="line">// html 结构为：ul#todo-list&gt;li.todo-item*5</span><br><span class="line"></span><br><span class="line">$(&apos;#todo-list&apos;).on(&apos;click&apos;, &apos;.todo-item&apos;, function() &#123;</span><br><span class="line">    $(this).toggleClass(&apos;done&apos;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>以 jQuery 为例，所以我们看不到背后的本质，下面我们以一个原生的实现来说明下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var todoList = document.getElementById(&quot;todo-list&quot;);</span><br><span class="line"></span><br><span class="line">todoList.addEventListener(&quot;click&quot;, function (e) &#123;</span><br><span class="line">    var target = e.target;</span><br><span class="line">    // 检查事件源 target 是否为 todo-item</span><br><span class="line">    if (target &amp;&amp; target.nodeName.toUpperCase() == &apos;LI&apos; &amp;&amp; target.classList.contains(&apos;todo-item&apos;)) &#123;</span><br><span class="line">        target.classList.toggle(&apos;done&apos;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(&apos;我不是 todo-item &apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>注：因为事件委托是依赖于事件冒泡的，所以没有事件冒泡的事件是不能使用事件委托的。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.diguage.com/archives/71.html" target="_blank" rel="noopener">实例分析JavaScript中的事件委托和事件绑定</a></li>
<li><a href="http://www.imooc.com/article/16468" target="_blank" rel="noopener">javascript: 事件委托解析</a></li>
<li><a href="https://eamiear.gitbooks.io/frontend/content/JavaScript%E6%A8%A1%E5%9D%97/JavaScript%E5%9F%BA%E7%A1%80/%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86_%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98.html" target="_blank" rel="noopener">事件委托</a></li>
</ul>
<h1 id="jQuery-隐式迭代和链式调用"><a href="#jQuery-隐式迭代和链式调用" class="headerlink" title="jQuery 隐式迭代和链式调用"></a>jQuery 隐式迭代和链式调用</h1><p>学过 jQuery 之后，一般是不太有人再愿意写原生 JS 的，甚至有段时间 jQuery 成了 JS 的代名词。原因无他，足够简单方便。可在这简单方便的背后，可少不了两大功臣：隐式迭代和链式调用。</p>
<h2 id="隐式迭代"><a href="#隐式迭代" class="headerlink" title="隐式迭代"></a>隐式迭代</h2><p>对于原生 JS 来说，一般我们设置某类元素的样式，都得使用循环设置，而 jQuery 在使用的时候则无需考虑这点，简单示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 设置 .primary 元素的文字颜色为 #188eee</span><br><span class="line"></span><br><span class="line">// 原生 JS</span><br><span class="line">var primary = document.getElementsByClassName(&apos;primary&apos;);</span><br><span class="line">for(var i = 0, len = primary.length; i &lt; len; i++) &#123;</span><br><span class="line">    primary[i].style.color = &apos;#188eee&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// jQuery</span><br><span class="line">$(&apos;.primary&apos;).css(&apos;color&apos;, &apos;#188eee&apos;);</span><br></pre></td></tr></table></figure>
<p>这是因为 jQuery 的方法内部存在<strong>隐式迭代</strong>，它会对匹配到的所有元素进行循环遍历，执行相应的方法；无需我们再手动地进行循，方便我们使用。</p>
<p>除了隐式迭代外，jQuery 还提供了 <a href="http://jquery.cuishifeng.cn/each.html" target="_blank" rel="noopener">each</a> 方法，方便有需要的时候调用。比喻要对每个元素做不同的处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;li&quot;).each(function(i)&#123;</span><br><span class="line">   $(this).addClass(&apos;item-&apos;+i);</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>
<p>注：jQuery 还有一个全局的 each 方法，用于遍历对象或数组，具体可参考：<a href="http://jquery.cuishifeng.cn/jQuery.each.html" target="_blank" rel="noopener">$.each</a></p>
<h2 id="链式编程"><a href="#链式编程" class="headerlink" title="链式编程"></a>链式编程</h2><p>从前我们要对某个元素进行一系列操作，只能一个一个来，而 jQuery 提供了链式操作，操作起来简直是不能再爽，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 原始版</span><br><span class="line">$(&apos;div&apos;).hide(); //隐藏页面上所有的div元素</span><br><span class="line">$(&apos;div&apos;).text(&apos;new content&apos;); //更新所有div元素内的文本</span><br><span class="line">$(&apos;div&apos;).addClass(&quot;updatedContent&quot;); //在所有的div元素上添加值为updatedContent的class属性</span><br><span class="line">$(&apos;div&apos;).show(); //显示页面上所有的div元素</span><br><span class="line"></span><br><span class="line">// 重写版，链式</span><br><span class="line">$(&apos;div&apos;).hide().text(&apos;new content&apos;).addClass(&quot;updatedContent&quot;).show();</span><br><span class="line"></span><br><span class="line">// 缩进版</span><br><span class="line">$(&apos;div&apos;)</span><br><span class="line">  .hide()</span><br><span class="line">  .text(&apos;new content&apos;)</span><br><span class="line">  .addClass(&quot;updatedContent&quot;)</span><br><span class="line">  .show();</span><br></pre></td></tr></table></figure>
<p>其原理就是每个方法的最后都返回了 this 对象，我们可以使用一份简单的代码演示下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 定义类</span><br><span class="line">function Person(opt) &#123;</span><br><span class="line">    this.name = opt.name;</span><br><span class="line">    this.age = opt.age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义 getName 方法</span><br><span class="line">Person.prototype.getName = function() &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">    return this; // 返回 this 对象</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义 sayHello 方法</span><br><span class="line">Person.prototype.sayHello = function() &#123;</span><br><span class="line">    console.log(&apos;hello the world&apos;);</span><br><span class="line">    return this; // 返回 this 对象</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 新建一个叫 next 的 Person 类</span><br><span class="line">var next = new Person(&#123;</span><br><span class="line">    name: &apos;next&apos;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 链式调用 getName 和 sayHello 方法</span><br><span class="line">next.getName().sayHello();</span><br></pre></td></tr></table></figure>
<p>更多关于 jQuery 的源码分析可参考：<a href="http://www.cnblogs.com/aaronjs/p/3279314.html" target="_blank" rel="noopener">jQuery源码分析系列</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Sponge</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">31</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sponge</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">67.2k</span>
  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'JAytK8dtYmfQUns7Dd8iG9zC-gzGzoHsz',
        appKey: 'Y3ImYMhiFYr5d6sIuyK3ej0Q',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
