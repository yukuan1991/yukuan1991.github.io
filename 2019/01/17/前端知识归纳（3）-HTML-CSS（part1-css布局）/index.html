<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="深入理解 HTML 语义HTML 语义当然不仅仅只是几个 HTML 语义标签。 从“文档”说起很多时候我会把“页面”和“文档”这两个词混着用，比如将 HTML 页面说成“HTML 文档”。 HTML 就是文档，最开始的《Web 简史》中我们有提到过，万维网的雏形是一个文档共享系统，万维网就是一个放大版的文档共享系统。 只是随着 Web 的发展，各种酷炫的页面和应用层出不穷，倒是让新入行的小伙伴忽略">
<meta property="og:type" content="article">
<meta property="og:title" content="前端知识归纳（3）-- HTML&#x2F;CSS（part1 css布局）">
<meta property="og:url" content="http://yoursite.com/2019/01/17/前端知识归纳（3）-HTML-CSS（part1-css布局）/index.html">
<meta property="og:site_name" content="Sponge的个人博客">
<meta property="og:description" content="深入理解 HTML 语义HTML 语义当然不仅仅只是几个 HTML 语义标签。 从“文档”说起很多时候我会把“页面”和“文档”这两个词混着用，比如将 HTML 页面说成“HTML 文档”。 HTML 就是文档，最开始的《Web 简史》中我们有提到过，万维网的雏形是一个文档共享系统，万维网就是一个放大版的文档共享系统。 只是随着 Web 的发展，各种酷炫的页面和应用层出不穷，倒是让新入行的小伙伴忽略">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/10350345-d6d1f5041224a51d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/10350345-e6ffa295d9c9be05.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/10350345-435353015091b351.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/10350345-0dace392a1086ff9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/10350345-53409db1b6b95702.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/10350345-cecc3e605b24748a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/10350345-c244028e61f61d43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/10350345-28aeee8f41e7c80e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/10350345-f1522ebb846fe68a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/10350345-3c2d48033c0eb6a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/10350345-560684d9882cd6e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/10350345-18c84baf750d002c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/10350345-31a29eaf067cbdba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/10350345-26aea0d17e5b6399.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/10350345-cfc3573611bd3d3d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/10350345-7938a7124129e937.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/10350345-c3450bc4911ea44c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/10350345-55ccf07f3486a556.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/10350345-daac84b0f490ab5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/10350345-337eb4ed0c4c4904.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/10350345-138d0c51a5e11840.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/10350345-626859657d98fd49.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/10350345-d597916c63587fcb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/10350345-9b6edc5b186b2e56.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/10350345-669993d92974b0d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/10350345-05e6311f6ac9263e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/10350345-7af4d4f1d812db95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/10350345-b8f3a0ca6658ac62.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/10350345-4779ab0912dc1970.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/10350345-bf30225adc0ec624.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/10350345-afe8c62eeb72d8d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/10350345-083303b8092ebd7b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2019-03-20T08:09:01.383Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="前端知识归纳（3）-- HTML&#x2F;CSS（part1 css布局）">
<meta name="twitter:description" content="深入理解 HTML 语义HTML 语义当然不仅仅只是几个 HTML 语义标签。 从“文档”说起很多时候我会把“页面”和“文档”这两个词混着用，比如将 HTML 页面说成“HTML 文档”。 HTML 就是文档，最开始的《Web 简史》中我们有提到过，万维网的雏形是一个文档共享系统，万维网就是一个放大版的文档共享系统。 只是随着 Web 的发展，各种酷炫的页面和应用层出不穷，倒是让新入行的小伙伴忽略">
<meta name="twitter:image" content="http://upload-images.jianshu.io/upload_images/10350345-d6d1f5041224a51d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/01/17/前端知识归纳（3）-HTML-CSS（part1-css布局）/">





  <title>前端知识归纳（3）-- HTML/CSS（part1 css布局） | Sponge的个人博客</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Sponge的个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/17/前端知识归纳（3）-HTML-CSS（part1-css布局）/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sponge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sponge的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">前端知识归纳（3）-- HTML/CSS（part1 css布局）</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-17T14:04:14+08:00">
                2019-01-17
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/01/17/前端知识归纳（3）-HTML-CSS（part1-css布局）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/01/17/前端知识归纳（3）-HTML-CSS（part1-css布局）/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  14.8k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  56
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="深入理解-HTML-语义"><a href="#深入理解-HTML-语义" class="headerlink" title="深入理解 HTML 语义"></a>深入理解 HTML 语义</h1><p>HTML 语义当然不仅仅只是几个 HTML 语义标签。</p>
<h2 id="从“文档”说起"><a href="#从“文档”说起" class="headerlink" title="从“文档”说起"></a>从“文档”说起</h2><p>很多时候我会把“页面”和“文档”这两个词混着用，比如将 HTML 页面说成“HTML 文档”。</p>
<p>HTML 就是文档，最开始的《Web 简史》中我们有提到过，万维网的雏形是一个文档共享系统，万维网就是一个放大版的文档共享系统。</p>
<p>只是随着 Web 的发展，各种酷炫的页面和应用层出不穷，倒是让新入行的小伙伴忽略了，HTML 的本质其实是文档（document）。</p>
<p>现实生活中，说到文档，我们的第一反应就是 Microsoft Word ，其实 Word 当年也有可能成为 Web 标准，当然这是另外一个故事。</p>
<h3 id="文档大纲"><a href="#文档大纲" class="headerlink" title="文档大纲"></a>文档大纲</h3><p>所以我们从 Word 说开去，希望你 Word 用的很顺溜哦。</p>
<p>Word 中的标题有一级标题、二级标题……的说法，所有的标题就构建出了这个 Word 文档的大纲。下图的左边栏就是大纲视图，可以很好的观察文档大纲。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/10350345-d6d1f5041224a51d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="word-outline"></p>
<p>在 HTML 文档中呢，H1 ~ H6 就是一级到六级标题，它们构成了 HTML 文档的大纲。下面是腾讯网首页的文档大纲。一个好的页面，必定先是一个好文档，好文档必然有着严谨的文档大纲。</p>
<p>这个是谷歌浏览器查看页面文档大纲的插件，<a href="https://chrome.google.com/webstore/detail/html5-outliner/afoibpobokebhgfnknfndkgemglggomo" target="_blank" rel="noopener">html5-outliner</a> 。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/10350345-e6ffa295d9c9be05.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="web-outline"></p>
<h2 id="再来看“万维网”"><a href="#再来看“万维网”" class="headerlink" title="再来看“万维网”"></a>再来看“万维网”</h2><p>最初的万维网是一个文档共享的网络，现在的万维网则是一个资源共享的网络，包括图片、多媒体等等。</p>
<p>HTML 则是万维网的粘合剂，也是万维网的载体，但是现在 HTML 给我们的感觉啊，就是给人看的，其实，HTML 同时也会给机器看，比如下图，除了 human 在读 HTML ，各式各样的机器也在读 HTML ，比如搜索引擎的爬虫和读屏设备。</p>
<p>视觉上的各种酷炫会给人以视觉冲击，但对机器来说，并没有什么用，它们更看重的是语义，这样才能更好地解析内容。这也是为什么样式会从结构里面分离出来的原因之一。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/10350345-435353015091b351.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="exploiting-html"></p>
<h2 id="现在才到-HTML-语义"><a href="#现在才到-HTML-语义" class="headerlink" title="现在才到 HTML 语义"></a>现在才到 HTML 语义</h2><p>本文的开头就提到了，HTML 语义当然不仅仅只是几个 HTML 语义标签。在 HTML 本身这个层面上，语义也有更多的东西，关于这些已经有不少前辈为我们总结好了，参考如下：</p>
<ul>
<li><a href="https://segmentfault.com/a/1190000002695791" target="_blank" rel="noopener">HTML5中最看重的理念“语义化”相比HTML有什么区别？</a></li>
<li><a href="http://justineo.github.io/slideshows/semantic-html/#/2" target="_blank" rel="noopener">HTML 语义</a></li>
</ul>
<h1 id="让-IE8-支持-HTML5-语义化标签"><a href="#让-IE8-支持-HTML5-语义化标签" class="headerlink" title="让 IE8 支持 HTML5 语义化标签"></a>让 IE8 支持 HTML5 语义化标签</h1><p>HTML5是 HTML 最新的修订版本，于2014年10月由万维网联盟（W3C）完成标准制定。而 IE8 面世时间为2009年3月19日，时间相差如此之大，所以 IE8 作为比较古老的浏览器，不支持 HTML 5 引入的语义化标签（如 header、nav、menu、section、article 等）也是很正常的。</p>
<h2 id="默认情况下-IE8-对-HTML5-标签的处理"><a href="#默认情况下-IE8-对-HTML5-标签的处理" class="headerlink" title="默认情况下 IE8 对 HTML5 标签的处理"></a>默认情况下 IE8 对 HTML5 标签的处理</h2><p>在 IE8 里面，未定义的标签——IE8 不认识所有新引入的 HTML5 标签，所以定义样式是不会生效。比如下面这段代码（抽取主要代码）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  section &#123; color: red; &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;section&gt;</span><br><span class="line">  hello world</span><br><span class="line">&lt;/section&gt;</span><br></pre></td></tr></table></figure>
<p>期待展示的效果如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/10350345-0dace392a1086ff9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="chrome"></p>
<p>但在 IE8 中实际展示效果如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/10350345-53409db1b6b95702.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="IE8"></p>
<h2 id="如何让-IE8-支持-HTML5-标签"><a href="#如何让-IE8-支持-HTML5-标签" class="headerlink" title="如何让 IE8 支持 HTML5 标签"></a>如何让 IE8 支持 HTML5 标签</h2><p>虽然默认不支持，但是我们可以通过 JS 使用 <code>document.createElement</code> 来“欺骗” IE 的 CSS 引擎，让它知道某个标签的存在，具体做法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;HTML5 test&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script&gt;</span><br><span class="line">      document.createElement(&apos;section&apos;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line"></span><br><span class="line">    &lt;style&gt;</span><br><span class="line">      section &#123; color: red; &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line"></span><br><span class="line">    &lt;section&gt;</span><br><span class="line">      Hello!</span><br><span class="line">    &lt;/section&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>显示效果如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/10350345-cecc3e605b24748a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="IE_HTML5"></p>
<p>既然元素默认都不支持，就更没有相关默认的样式了，所以我们还要加上一些重置样式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">article, aside, details, figcaption, figure, footer, header, hgroup, main, menu, nav, section, summary &#123;</span><br><span class="line">  display: block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="借助-html5shiv-js-让-IE8-支持更多的-HTML5-特性"><a href="#借助-html5shiv-js-让-IE8-支持更多的-HTML5-特性" class="headerlink" title="借助 html5shiv.js 让 IE8 支持更多的 HTML5 特性"></a>借助 <code>html5shiv.js</code> 让 IE8 支持更多的 HTML5 特性</h2><p>其实不只是 IE8 ， IE6-9、 Safari 4.x (以及 iPhone 3.x)、还有Firefox 3.x 等等，对 HTML5 的支持都不完善。所以有了一个库 <code>html5shiv.js</code> 来做统一处理，shiv 意为用作武器的小刀（实际上是一个拼写错误，应该为 shim），在机械工程中的专业释义为垫片，比喻给那些老旧的浏览器加个垫片，让它们基本能用。</p>
<h2 id="更多阅读"><a href="#更多阅读" class="headerlink" title="更多阅读"></a>更多阅读</h2><ul>
<li><a href="http://intertwingly.net/blog/2008/01/22/Best-Standards-Support#c1201006277" target="_blank" rel="noopener">IE8 HTML5 surport</a></li>
<li><a href="http://ejohn.org/blog/html5-shiv/" target="_blank" rel="noopener">HTML5 shiv</a></li>
<li><a href="https://github.com/aFarkas/html5shiv/" target="_blank" rel="noopener">html5shiv.js</a></li>
<li><a href="http://www.zhangxinxu.com/wordpress/2013/02/github-html5shiv-readme-translate/" target="_blank" rel="noopener">github上html5shiv项目readme.md部分的翻译</a></li>
<li><a href="http://note.rpsh.net/posts/2011/05/25/story-of-html5-shiv/" target="_blank" rel="noopener">HTML5 Shiv 的一些趣事</a> ，英文原文见 <a href="http://paulirish.com/2011/the-history-of-the-html5-shiv/" target="_blank" rel="noopener">The Story of the HTML5 Shiv</a>。</li>
</ul>
<h1 id="视觉格式化模型（visual-formatting-model）"><a href="#视觉格式化模型（visual-formatting-model）" class="headerlink" title="视觉格式化模型（visual formatting model）"></a>视觉格式化模型（visual formatting model）</h1><p>前面我们已经学习了盒模型（box model），知道了元素会被渲染成一个个盒子。那么这些盒子在屏幕上的位置又是怎么放置的呢？这就是我们现在要学习的——CSS 视觉格式化模型(visual formatting model)。视觉格式化模型是 CSS 布局的一个基础理论体系，需要你有一定的 CSS 功底，所以一时半会是很难掌握的，但是只要你一掌握，对于 CSS 布局就会豁然开朗。（建议整个 CSS 布局学完后再重新细读深入下。）</p>
<h2 id="盒子的位置摆放"><a href="#盒子的位置摆放" class="headerlink" title="盒子的位置摆放"></a>盒子的位置摆放</h2><p>默认情况下，盒子按照元素在 HTML 中的先后位置从左至右自上而下一个接着一个排列摆放。如下图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/10350345-c244028e61f61d43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>在图中我们可以看到，有些元素的盒子被渲染为完整的一行，如h1、p、div；而有些元素的盒子则被渲染为水平排列，直到该行被占满然后换行，如span、a、strong。</p>
<p>这是因为不同的盒子使用的是不同的格式化上下文（formatting context）来布局，每个格式化上下文都拥有一套不同的渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。（就如我们参加结婚喜宴一样，有父母长辈席，好友席，同事席，甚至前男/女朋友席等，不同的身份坐到对应位置即可。）</p>
<h2 id="格式化上下文（formatting-context）"><a href="#格式化上下文（formatting-context）" class="headerlink" title="格式化上下文（formatting context）"></a>格式化上下文（formatting context）</h2><p>我们常见的两个格式化上下文分别为：块格式化上下文（block formatting context 简称 BFC）和行内格式化上下文（inline formatting context 简称 IFC）</p>
<h3 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h3><h4 id="块级盒（block-level-boxes）"><a href="#块级盒（block-level-boxes）" class="headerlink" title="块级盒（block-level boxes）"></a>块级盒（block-level boxes）</h4><p>当元素的 CSS 属性 display 的计算值为 block，list-item，table，flex 或 grid 时，它是<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Block-level_elements" target="_blank" rel="noopener">块级元素</a>。视觉上呈现为块，竖直排列。典型的如 <code>&lt;div&gt;</code> 元素，<code>&lt;p&gt;</code> 元素等都是块级元素。</p>
<p>每个块级元素至少生成一个块级盒，称为主要块级盒(principal block-level box)。一些元素，比如<code>&lt;li&gt;</code>，生成额外的盒来放置项目符号，不过多数元素只生成一个主要块级盒。</p>
<p>块级盒参与 BFC，被渲染为完整的一个新行。</p>
<h4 id="渲染规则"><a href="#渲染规则" class="headerlink" title="渲染规则"></a>渲染规则</h4><p>默认根元素（html 元素）会创建一个 BFC，其块级盒子元素将会按照如下规则进行渲染：</p>
<ul>
<li>块级盒会在垂直方向，一个接一个地放置，每个盒子水平占满整个容器空间</li>
<li>块级盒的垂直方向距离由上下 margin 决定，同属于一个 BFC 中的两个或以上块级盒的相接的 margin 会发生重叠</li>
<li>BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此</li>
<li>计算 BFC 的高度时，浮动元素也参与计算</li>
</ul>
<p>除此之外，还有其他方法可以创建一个新的 BFC，具体可参看：<a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context" target="_blank" rel="noopener">块格式化上下文</a>。除此之外，flexbox 布局和 grids 布局中的 item 都会创建一个新的 BFC。</p>
<p>具体渲染规则及效果可参看：<a href="http://coding.imweb.io/demo/p3/vfm/bfc.html" target="_blank" rel="noopener">块格式化上下文</a></p>
<p>更多关于 BFC 相关内容可参看：</p>
<ul>
<li><a href="https://www.w3.org/TR/CSS22/visuren.html#block-formatting" target="_blank" rel="noopener">Block formatting contexts</a></li>
<li><a href="http://www.html-js.com/article/1866" target="_blank" rel="noopener">CSS 之 BFC 详解</a></li>
</ul>
<h3 id="IFC"><a href="#IFC" class="headerlink" title="IFC"></a>IFC</h3><h4 id="行内级盒（inline-level-boxes）"><a href="#行内级盒（inline-level-boxes）" class="headerlink" title="行内级盒（inline-level boxes）"></a>行内级盒（inline-level boxes）</h4><p>当元素的 CSS 属性 display 的计算值为 inline，inline-block，inline-table，inline-flex 或 inline-grid 时，它是<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Inline_elemente" target="_blank" rel="noopener">行内级元素</a>。视觉上它将内容与其它行内级元素排列为一行，直到该行被占满然后换行。典型的如段落内容，文本或图片，都是行内级元素。</p>
<p>注：由于目前几乎所有资料都将行内元素当做行内<strong>级</strong>元素，所以前面的课程我们也遵循这个美丽的错误。严格来说，行内元素不包括 inline-block 的，行内级元素才包括。我们要理解其中的区别，知晓这个美丽的错误。</p>
<p>行内级元素生成行内级盒，参与行内格式化上下文（inline formatting context），被渲染为水平排列, 直到当行被占满然后换行。</p>
<p>行内级盒分为行内盒（inline boxes）和原子行内级盒(atomic inline-level boxes)。前者由非<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Replaced_element" target="_blank" rel="noopener">置换元素</a>且 display 值为 inline 的元素生成；后者由行内级置换元素，或 display 值为 inline-block, inline-table, inline-flex, inline-grid 的元素生成。</p>
<p>每一行排列的行内级盒都可以看做由一个匿名的行盒包裹，如下图（使用了两种灰色背景色来模拟）：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/10350345-28aeee8f41e7c80e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h4 id="渲染规则-1"><a href="#渲染规则-1" class="headerlink" title="渲染规则"></a>渲染规则</h4><p>当块容器盒（block container box）不包括任何块级盒（block-level boxes）时，就会创建一个行内格式化上下文（IFC）。（一般来说一个块级盒也是一个块容器盒，具体可参看： <a href="https://www.w3.org/TR/CSS22/visuren.html#block-boxes" target="_blank" rel="noopener">Block-level elements and block boxes</a>）</p>
<p>IFC 中的行内级盒将会按照如下规则进行渲染（规则有点多，大概主要点就是行盒，折行机制，水平对齐方式，垂直高度及垂直对齐方式）：</p>
<ul>
<li>盒子一个接一个地水平摆放，当容器宽度不够时就会换行</li>
<li>在水平方向上，这些盒的外边距、边框、内边距所占用的空间都会被计算，但行内盒的垂直的border，padding 与 margin 都不会撑开行盒的高度</li>
<li>在垂直方向上，这些盒可能会以不同形式来对齐，可通过 vertical-align 来设置，默认对齐为 baseline</li>
<li>每一行将生成一个行盒（line box），包括该行所有的盒子，行盒的宽度是由包含块和存在的浮动来决定</li>
<li>行盒一般左右边都贴紧其包含块，但是会因为浮动盒（float 元素）的存在而发生变化。浮动盒会位于包含块边缘与行盒边缘之间，这样行盒的可用宽度就小于包含块的宽度</li>
<li>当所有盒的总宽度小于行盒的宽度，那么行盒中的水平方向排版由 text-align 属性来决定</li>
<li>当所有盒的总宽度超过一个行盒时，就会形成多个行盒，多个行盒相互之间垂直方向不能分离，不能重叠</li>
<li>当一个行内盒超过行盒的宽度时，它会被分割成多个盒，这些盒被分布在多个行盒里。如果一个行内盒不能被分割（比如只包含单个字符，或word-breaking机制被禁用，或该行内框受white-space属性值为nowrap或pre的影响），那么这个行内盒将溢出这个行盒</li>
<li>当一个行内盒发生分割时，分割处的 margins, borders 和 padding 不会有任何视觉效果（或者其他任何分裂，只要是有多个行盒）</li>
<li>行盒的高度由内部元素中实际高度最高的元素计算出来。每个行盒的高度由于内容不一样，所以高度也可能不一样</li>
<li>在一个行盒中，当他包含的内部容器的高度小于行盒的高度的时候，内部容器的垂直位置可由自己的 vertical-align 属性来确定</li>
</ul>
<p>注：在 IFC 的环境中，是不能存在块级元素的，如果将块级元素插入到 IFC 中，那么此 IFC 将会被破坏掉变成 BFC，而块级元素前的元素或文本和块级元素后的元素或文本将会各自自动产生一个匿名块盒其包围。</p>
<p>具体行盒高度及垂直对齐方式渲染效果可参看：</p>
<ul>
<li><a href="http://coding.imweb.io/demo/p3/vfm/ifc-height.html" target="_blank" rel="noopener">行盒高度</a></li>
<li><a href="http://coding.imweb.io/demo/p3/vfm/ifc-vertical-align.html" target="_blank" rel="noopener">行内级元素垂直对齐方式</a></li>
</ul>
<p>更多关于 IFC 相关内容可参看：</p>
<ul>
<li><a href="https://www.w3.org/TR/CSS22/visuren.html#inline-formatting" target="_blank" rel="noopener">Inline formatting contexts</a></li>
<li><a href="http://www.cnblogs.com/rainman/archive/2011/08/05/2128068.html" target="_blank" rel="noopener">深入理解CSS中的行高</a></li>
</ul>
<h3 id="其他格式化上下文"><a href="#其他格式化上下文" class="headerlink" title="其他格式化上下文"></a>其他格式化上下文</h3><p>除此之外，还有一些其他不同类型的盒子，如下：</p>
<ul>
<li><a href="https://www.w3.org/TR/CSS22/tables.html#model" target="_blank" rel="noopener">表格布局</a>：可以创建一个表格包裹盒(table wrapper box)，包括了表格盒(table box)及任何标题盒(caption boxes)。</li>
<li><a href="https://www.w3.org/TR/css3-multicol/#the-multi-column-model" target="_blank" rel="noopener">多列布局</a>：可以在容器盒与内容之间创建列盒(column boxes)</li>
<li><a href="https://www.w3.org/TR/css-flexbox-1/##flex-containers" target="_blank" rel="noopener">弹性布局</a>：将会创建一个弹性容器盒（flex container box）</li>
<li><a href="https://www.w3.org/TR/css-grid-1/#grid-model" target="_blank" rel="noopener">网格布局</a>：将会创建一个网格容器盒（grid container box）</li>
</ul>
<p>而这些盒子也将采用不用的格式化上下文来渲染，如 table formatting context（table 布局）、flex formatting context（flexbox 布局）、grid formatting context（grid 布局）。</p>
<p>更多关于盒子的介绍可参看：</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Visual_formatting_model#.E7.9B.92.E7.9A.84.E7.94.9F.E6.88.90(Box_generation" target="_blank" rel="noopener">盒子的生成</a>)</li>
<li><a href="http://blog.doyoe.com/2015/03/09/css/%E8%A7%86%E8%A7%89%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%A8%A1%E5%9E%8B%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A1%86/" target="_blank" rel="noopener">视觉格式化模型中的各种框</a></li>
</ul>
<h2 id="定位方案"><a href="#定位方案" class="headerlink" title="定位方案"></a>定位方案</h2><p>上面我们所讨论的其实都是常规流（normal flow）中盒子的摆放。但实际上我们有三种定位方案，分别为：</p>
<ul>
<li>常规流（normal flow）：盒一个接一个排列，不同的盒子采用不同的格式化上下文渲染。</li>
<li>浮动（float）：盒将从常规流里提出来，放在当前盒的旁边。</li>
<li>绝对定位(absolute positioning)：盒将脱离常规流，其坐标是绝对的（通过 top / bottom / left / right 来设置）。</li>
</ul>
<h3 id="常规流（normal-flow）"><a href="#常规流（normal-flow）" class="headerlink" title="常规流（normal flow）"></a>常规流（normal flow）</h3><p>默认盒的定位方案就是常规流，但是如果触发了以下任何一个条件，将不会使用常规流：</p>
<ul>
<li>position 的值非 static 或 relative</li>
<li>float 的值非 none</li>
</ul>
<p>在常规流中，不同的盒子将采用不同的格式化上下文渲染，也就是上面所讲的部分。</p>
<h3 id="浮动（float）"><a href="#浮动（float）" class="headerlink" title="浮动（float）"></a>浮动（float）</h3><p>对于浮动定位方案, 盒称为浮动盒（floating boxes）。它位于当前行的开头或末尾。这导致常规流环绕在它的周边，除非设置 clear 属性。</p>
<p>要使用浮动定位方案，元素 CSS 属性 position 必须为 static 或 relative，然后 float 不为 none 。如果 float 设为 left, 则浮动定位到当前位置的开始位置，如果设为 right, 则浮动定位到当前位置的最后位置。</p>
<p>具体介绍可学习下面章节：元素浮动——float。</p>
<h3 id="绝对定位（absolute-position）"><a href="#绝对定位（absolute-position）" class="headerlink" title="绝对定位（absolute position）"></a>绝对定位（absolute position）</h3><p>如果元素的属性 position 不是 static 或 relative， 那它就是绝对定位元素。</p>
<p>对于绝对定位方案，盒从常规流中被移除，不影响常规流的布局。 它的定位相对于它的包含块，定位坐标可通过属性 top、bottom、left、right 来设置 。</p>
<p>固定定位元素(fixed positioned element)也是绝对定位元素，它的包含块是视口。当页面滚动时它固定在屏幕上，因为视口没有移动。</p>
<p>具体介绍可学习下面章节：元素定位——position。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Visual_formatting_model" target="_blank" rel="noopener">视觉格式化模型 | MDN</a></li>
<li><a href="http://www.cnblogs.com/winter-cn/archive/2012/11/13/2768732.html" target="_blank" rel="noopener">CSS layout 入门</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Layout_mode" target="_blank" rel="noopener">Layout mode | MDN</a></li>
</ul>
<h1 id="深入了解-inline-block"><a href="#深入了解-inline-block" class="headerlink" title="深入了解 inline-block"></a>深入了解 inline-block</h1><p>在之前的课程中，我们学习到了 inline-block 的基础知识，接下来我将介绍一些使用 inline-block 产生的问题和解决方法以及其常见的应用场景，来进一步加深了大家对 inline-block 的理解。</p>
<h2 id="水平间隙问题"><a href="#水平间隙问题" class="headerlink" title="水平间隙问题"></a>水平间隙问题</h2><p>我们创建一个导航列表，并将其列表 item 设置为 inline-block，主要代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;nav&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;nav-item&quot;&gt;&lt;a&gt;导航&lt;/a&gt;&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;nav-item&quot;&gt;&lt;a&gt;导航&lt;/a&gt;&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;nav-item&quot;&gt;&lt;a&gt;导航&lt;/a&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.nav &#123;</span><br><span class="line">  background: #999;</span><br><span class="line">&#125;</span><br><span class="line">.nav-item&#123;</span><br><span class="line">  display:inline-block; /* 设置为inline-block */</span><br><span class="line">  width: 100px;</span><br><span class="line">  background: #ddd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果图如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/10350345-f1522ebb846fe68a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>我们从效果图中可以看到列表 item 之间有一点小空隙，但是我们在代码中并没有设置 margin 水平间距。那么这个空隙是如何产生的呢？</p>
<p>这是因为我们编写代码时输入空格、换行都会产生空白符。而浏览器是不会忽略空白符的，且对于多个连续的空白符浏览器会自动将其合并成一个，故产生了所谓的间隙。</p>
<p>对于上面实例，我们在列表 item 元素之间输入了回车换行以方便阅读，而这间隙正是这个回车换行产生的空白符。</p>
<p>同样对于所有的行内元素（inline，inline-block），换行都会产生空白符的间隙。</p>
<h3 id="如何消除空白符"><a href="#如何消除空白符" class="headerlink" title="如何消除空白符"></a>如何消除空白符</h3><p>从上面我们了解到空白符，是浏览器正常的表现行为。但是对于某些场景来说，并不美观，而且间隙大小非可控，所以我们往往需要去掉这个空白间隙。一般来说我们有两种方法来去掉这个换行引起间隙：代码不换行和设置 font-size。</p>
<h4 id="代码不换行"><a href="#代码不换行" class="headerlink" title="代码不换行"></a>代码不换行</h4><p>我们了解到，由于换行空格导致产生换行符，因此我们可以将上述例子中的列表 item 写成一行，这样空白符便消失，间隙就不复存在了。其代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;nav&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;nav-item&quot;&gt;导航&lt;/div&gt;&lt;div class=&quot;nav-item&quot;&gt;导航&lt;/div&gt;&lt;div class=&quot;nav-item&quot;&gt;导航&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>但考虑到代码可读及维护性，我们一般不建议连成一行的写法。</p>
<h4 id="设置-font-size"><a href="#设置-font-size" class="headerlink" title="设置 font-size"></a>设置 font-size</h4><p>首先要理解空白符归根结底是个字符，因此，我们可以通过设置 font-size 属性来控制产生的间隙的大小。我们知道如果将 font-size 设置为 0，文字字符是没法显示的，那么同样这个空白字也没了，间隙也就没了。</p>
<p>于是顺着这个思路就有了另一个解决方案：通过设置父元素的 font-size 为 0 来去掉这个间隙，然后重置子元素的 font-size，让其恢复子元素文字字符。</p>
<p>所以该方法代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.nav &#123;</span><br><span class="line">  background: #999;</span><br><span class="line">  font-size: 0; /* 空白字符大小为0 */</span><br><span class="line">&#125;</span><br><span class="line">.nav-item&#123;</span><br><span class="line">  display:inline-block;</span><br><span class="line">  width: 100px;</span><br><span class="line">  font-size: 16px; /* 重置 font-size 为16px*/</span><br><span class="line">  background: #ddd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用该方法时需要特别注意其子元素一定要重置 font-size，不然很容易掉进坑里（文字显示不出来）。</p>
<h2 id="对齐问题"><a href="#对齐问题" class="headerlink" title="对齐问题"></a>对齐问题</h2><p>由于 inline-block 属于行内级元素，所以 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/vertical-align" target="_blank" rel="noopener">vertical-align</a> 属性同样对其适用。</p>
<p>在正式讲解 vertical-align 之前，我们需要先说一些基本概念。</p>
<h3 id="中线、基线、顶线、底线"><a href="#中线、基线、顶线、底线" class="headerlink" title="中线、基线、顶线、底线"></a>中线、基线、顶线、底线</h3><p>中线（middle）、基线（baseline）、顶线（text-top、底线（text-bottom））是文本的几个基本线，其对应位置如下图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/10350345-3c2d48033c0eb6a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<ul>
<li>基线（base line）：小写英文字母<code>x</code>的下端沿。</li>
<li>中线（middle line）：小写英文字母<code>x</code>的中间。</li>
<li>顶线（text-top）：父元素 font-size 大小所组成的一个内容区域的顶部</li>
<li>底线（text-bottom）：父元素 font-size 大小所组成的一个内容区域的底部</li>
</ul>
<h3 id="vertical-align-的值"><a href="#vertical-align-的值" class="headerlink" title="vertical-align 的值"></a>vertical-align 的值</h3><p>vertical-align 只接受8个关键字、一个百分数值或者一个长度值。下面我们将看看各关键字如何作用于行内元素。</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>baseline</td>
<td>默认元素的基线与父元素的基线对齐。</td>
</tr>
<tr>
<td>sub</td>
<td>将元素的基线与其父元素的下标基线对齐。</td>
</tr>
<tr>
<td>super</td>
<td>将元素的基线与其父代的上标 - 基线对齐。</td>
</tr>
<tr>
<td>text-top</td>
<td>将元素的顶部与父元素的字体顶部对齐。</td>
</tr>
<tr>
<td>text-bottom</td>
<td>将元素的底部与父元素的字体的底部对齐。</td>
</tr>
<tr>
<td>middle</td>
<td>将元素的中间与基线对齐加上父元素的x-height的一半。</td>
</tr>
<tr>
<td>top</td>
<td>将元素的顶部和其后代与整行的顶部对齐。</td>
</tr>
<tr>
<td>bottom</td>
<td>将元素的底部和其后代与整行的底部对齐。</td>
</tr>
<tr>
<td><code>&lt;length&gt;</code></td>
<td>将元素的基线对准给定长度高于其父元素的基线。</td>
</tr>
<tr>
<td><code>&lt;percentage&gt;</code></td>
<td>像&lt;长度&gt;值，百分比是line-height属性的百分比。</td>
</tr>
</tbody>
</table>
<p>具体 demo 可参考：<a href="http://coding.imweb.io/demo/p3/vfm/ifc-vertical-align.html" target="_blank" rel="noopener">行内级元素垂直对齐方式</a></p>
<h1 id="清除浮动详解"><a href="#清除浮动详解" class="headerlink" title="清除浮动详解"></a>清除浮动详解</h1><p>清除浮动主要是为了解决由于浮动元素脱离文流导致的元素重叠或者父元素高度坍塌的问题，而这两个问题分别对应了需要清除浮动的两种种情况：清除前面兄弟元素浮动和闭合子元素浮动（解决父元素高度坍塌）。</p>
<h2 id="清除前面兄弟元素浮动"><a href="#清除前面兄弟元素浮动" class="headerlink" title="清除前面兄弟元素浮动"></a>清除前面兄弟元素浮动</h2><p>清除前面兄弟元素浮动很简单，只需要在不想受到浮动元素影响的元素上使用 <code>clear:both</code> 即可， HTML &amp; CSS 代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;fl&quot;&gt;我是左浮动元素&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;fr&quot;&gt;我是右浮动元素&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;cb&quot;&gt;我不受浮动元素的影响&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.fl &#123;</span><br><span class="line">    float: left;</span><br><span class="line">&#125;</span><br><span class="line">.fr &#123;</span><br><span class="line">    float: right;</span><br><span class="line">&#125;</span><br><span class="line">.cb &#123;</span><br><span class="line">    clear: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 CSS2 以前，clear 的原理为自动增加元素的上外边距（margin-top）值，使之最后落在浮动元素的下面。在 CSS2.1 中引入了一个清除区域（clearance）——在元素上外边距之上增加的额外间距，使之最后落在浮动元素的下面。所以如果需要设置浮动元素与 clear 元素的间距，得设置浮动的元素的 margin-bottom，而不是 clear 元素的 margin-top。</p>
<p>demo 可见：<a href="http://coding.imweb.io/demo/p3/float-clear-margin.html" target="_blank" rel="noopener">clear 清除浮动</a></p>
<h2 id="闭合子元素浮动"><a href="#闭合子元素浮动" class="headerlink" title="闭合子元素浮动"></a>闭合子元素浮动</h2><p>我们知道，在计算页面排版的时候，如果没有设置父元素的高度，那么该父元素的高度是由他的子元素高度撑开的。但是如果子元素是设置了浮动，脱离了文档流，那么父元素计算高度的时候就会忽略该子元素，甚至当所有子元素都是浮动的时候，就会出现父元素高度为 0 的情况，这就是所谓的父元素高度坍塌问题。为了能让父元素正确包裹子元素的高度，不发生坍塌，我们需要闭合子元素的浮动。</p>
<p>一般我们有两种办法可以用来闭合子元素浮动：</p>
<ul>
<li>给最后一个元素设置 <code>clear: both</code></li>
<li>给父元素新建一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context" target="_blank" rel="noopener">BFC</a>(块格式化上下文)</li>
</ul>
<h3 id="clear-both"><a href="#clear-both" class="headerlink" title="clear:both"></a><code>clear:both</code></h3><p>由于我们最后一个元素使用 <code>clear:both</code>，所以该元素就能不受浮动元素影响出现在父元素的最底部，而父元素计算高度的时候需要考虑到这个正常元素的位置，所以高度自然包裹到了最底部，也就没有了坍塌。</p>
<p>对于这个方法，以前我们是利用新增一个空元素（<code>&lt;b&gt;</code> 或 <code>&lt;span&gt;</code> 或 <code>&lt;div&gt;</code> 等）来实现的，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;span class=&quot;clear-box&quot;&gt;&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">    float: left;</span><br><span class="line">&#125;</span><br><span class="line">.clear-box &#123;</span><br><span class="line">    clear: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然这种办法比较直观，但是不是很优雅，因为增加了一个无用的空白标签，比较冗余而且不方便后期维护（一般不太建议使用该办法）。所以后期有了通过父元素的伪元素（::after）实现的著名 clearfix 方法，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;container clearfix&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.clearfix::after &#123;</span><br><span class="line">    content:&quot;&quot;;</span><br><span class="line">    display:table;</span><br><span class="line">    clear: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面方法给父元素增加一个专门用于处理闭合子元素浮动的 <code>clearfix</code> 类名，该类使用 <code>::after</code> 伪元素类选择器增加一个内容为空的结构来清除浮动，可能你们比较疑惑的是为什么要设置 <code>display:table</code> 属性，这其实涉及到一个比较复杂的进化过程，具体可以参考资料——<a href="http://web.jobbole.com/85965/" target="_blank" rel="noopener">clearfix浮动进化史</a></p>
<h3 id="新建-BFC"><a href="#新建-BFC" class="headerlink" title="新建 BFC"></a>新建 BFC</h3><p>该方法的原理是：父元素在新建一个 BFC 时，其高度计算时会把浮动子元素的包进来。</p>
<p>下面我们以实例为证：如下图我们的图片为浮动，父元素 article 的高度就出现了坍塌（没有包括图片），而根元素 HTML （默认情况下我们的根元素 HTML 就是一个 BFC）的高度则包括了图片的高度。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/10350345-560684d9882cd6e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/10350345-18c84baf750d002c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>既然新建一个 BFC 可以解决父元素高度坍陷问题，那就好办了，下面这些都可以创建一个 BFC ：</p>
<ul>
<li>根元素或其它包含它的元素</li>
<li>浮动 (元素的 float 不是 none)</li>
<li>绝对定位的元素 (元素具有 position 为 absolute 或 fixed)</li>
<li>内联块 inline-blocks (元素具有 display: inline-block)</li>
<li>表格单元格 (元素具有 display: table-cell，HTML表格单元格默认属性)</li>
<li>表格标题 (元素具有 display: table-caption, HTML表格标题默认属性)</li>
<li>块元素具有overflow ，且值不是 visible</li>
<li>display: flow-root</li>
</ul>
<p>虽然有这么多方法可用，可我们常用的就是 <code>overflow: hidden</code>，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">&#125;</span><br><span class="line">.box &#123;</span><br><span class="line">    float: left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面主要讲解了我们比较常的一些清除浮动解决方案，看似简单的清除浮动方法其实则涉及到了很多复杂的CSS规则，大家在实际操作的时候可以针对不同的情况参考上面的方法。</p>
<h1 id="深入了解-z-index"><a href="#深入了解-z-index" class="headerlink" title="深入了解 z-index"></a>深入了解 z-index</h1><p>网页正常文档流排版可以理解为在一个平面立面里面，元素占据空间，依次排列，互不覆盖。但是当页面中元素设置了定位属性的时候，难免会出现元素之间相互重叠的情况，比如下图小猫和小狗的图片都设置了绝对定位，2张图片的位置重叠了，小猫图显示在小狗图上面。现在如果我们想要小狗图显示在上面，就需要涉及到 CSS 中的 z-index 属性了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/10350345-31a29eaf067cbdba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="z-index"></p>
<h2 id="z-index"><a href="#z-index" class="headerlink" title="z-index"></a>z-index</h2><p>z-index 属性用于指定已定位元素在垂直于页面方向的排列顺序，其属性值有2种：<code>auto</code>（默认值）和整数。这里有2个需要注意的点：</p>
<ol>
<li>z-index 属性只对定位元素元素生效，也就是 position 属性不为 static 的元素。</li>
<li>除了默认值 <code>auto</code>， z-index 可以设置为任意整数，正数，0，负数都可以。</li>
</ol>
<p>一般情况下，z-index 值进行比较有下面2条规则：</p>
<ol>
<li>数值大的在上面(<code>auto</code> 数值上相当于0)。</li>
<li>数值相同的，在 HTML 结构中排后面的在上面。</li>
</ol>
<p>所以上面例子，2张图都没设置 z-index 的值，在 dom 结构上排后面的小猫图展示在上面。如果想小狗图展示在小猫图上面，只需要设置小狗图的 z-index 属性值大于0就可以了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;img class=&quot;dog&quot; src=&quot;http://coding.imweb.io/img/p3/z-index/dog.png&quot; alt=&quot;dog&quot;&gt;</span><br><span class="line">&lt;img class=&quot;cat&quot; src=&quot;http://coding.imweb.io/img/p3/z-index/cat.png&quot; alt=&quot;cat&quot;&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.dog &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 10px;</span><br><span class="line">  left: 100px;</span><br><span class="line">  z-index: 1; /* 设置小狗图的 z-index 值大于0 */</span><br><span class="line">&#125;</span><br><span class="line">.cat &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 80px;</span><br><span class="line">  left: 70px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>给 <code>.dog</code> 元素增加了 <code>z-index: 1</code> 属性就可以让小狗图相比于小猫图在垂直于页面的方向上离我们更近，这样效果就是小狗图显示在上面了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/10350345-26aea0d17e5b6399.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="z-index"></p>
<h2 id="层叠上下文"><a href="#层叠上下文" class="headerlink" title="层叠上下文"></a>层叠上下文</h2><p>上面说到，z-index 默认值 <code>auto</code> 数值上等于0，那设置了 <code>z-index:0</code> 和 默认的 <code>z-index:auto;</code> 有没有区别呢？ 答案是有区别的。区别在于设置了 z-index 属性为整数值(包括0)的元素，自身会创建一个层叠上下文。而创建一个层叠上下文之后，其子元素的层叠顺序就相对于父元素计算，不会与外部元素比较。这样说比较抽象，我们来看个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;dog-container&quot;&gt;</span><br><span class="line">  &lt;img class=&quot;dog&quot; src=&quot;http://coding.imweb.io/img/p3/z-index/dog.png&quot; alt=&quot;dog&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;cat-container&quot;&gt;</span><br><span class="line">  &lt;img class=&quot;cat&quot; src=&quot;http://coding.imweb.io/img/p3/z-index/cat.png&quot; alt=&quot;cat&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">img &#123;</span><br><span class="line">  width: 200px;</span><br><span class="line">&#125;</span><br><span class="line">.dog-container &#123;</span><br><span class="line">  width: 200px;</span><br><span class="line">  height: 100px;</span><br><span class="line">  background: red;</span><br><span class="line">  position: relative;</span><br><span class="line">  z-index: auto; /* 默认值auto */</span><br><span class="line">&#125;</span><br><span class="line">.dog &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 10px;</span><br><span class="line">  left: 100px;</span><br><span class="line">  z-index: 2;</span><br><span class="line">&#125;</span><br><span class="line">.cat &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 80px;</span><br><span class="line">  left: 70px;</span><br><span class="line">  z-index: 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面例子中，我们给 <code>.dog</code> 和 <code>.cat</code> 增加了容器 <code>.dog-container</code> 和 <code>.cat-container</code>, 并且 <code>.dog</code> 和 <code>.cat</code> 都设置了 <code>z-index</code> 值，所以都显示在红色背景的 <code>.container</code> 之上，而且 <code>.dog</code> z-index 数值比较大，所以显示在上面。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/10350345-cfc3573611bd3d3d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="z-index"></p>
<p>但是当我们设置了 <code>.dog-container</code> 的 z-index 属性值为0之后，我们发现，z-index 值比较大的 <code>.dog</code> 元素反而到 z-index值比较小的 <code>.cat</code> 下面了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.dog-container &#123;</span><br><span class="line">  width: 200px;</span><br><span class="line">  height: 100px;</span><br><span class="line">  background: red;</span><br><span class="line">  position: relative;</span><br><span class="line">  z-index: 0; /* 将 z-index 值改成0 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/10350345-7938a7124129e937.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="z-index"></p>
<p>其原因就在于我们给 <code>.dog-container</code> 设置了 <code>z-index:0</code> 之后，<code>.dog-container</code> 就创建了自己的层叠上下文，其子元素 <code>.dog</code> 在比较层叠顺序的时候只会在 <code>.dog-container</code> 内比较，而不会与外面的 <code>.cat</code> 比较。如下图所示:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/10350345-c3450bc4911ea44c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="z-index"></p>
<p>上面例子告诉我们，并不是所有情况 z-index 值大的元素都会在上面，我们在进行 z-index 比较的时候要留意其祖先元素有没有建立独立的层叠上下文，z-index 只有在同一个层叠上下文中比较才有意义。另外，对定位元素设置 z-index 属性不是唯一创建层叠上下文的方法，具有下面属性的元素都会创建层叠上下文（具体可参看：<a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context" target="_blank" rel="noopener">层叠上下文 | MDN</a>）：</p>
<ul>
<li>根元素 (HTML)</li>
<li>z-index 值不为 “auto”的 绝对/相对定位</li>
<li>一个 z-index 值不为 “auto”的 flex 项目 (flex item)，即：父元素 display: flex|inline-flex</li>
<li>opacity 属性值小于 1 的元素</li>
<li>transform 属性值不为 “none”的元素，</li>
<li>mix-blend-mode 属性值不为 “normal”的元素，</li>
<li>filter值不为“none”的元素，</li>
<li>perspective值不为“none”的元素，</li>
<li>isolation 属性被设置为 “isolate”的元素，</li>
<li>position: fixed</li>
<li>在 will-change 中指定了任意 CSS 属性，即便你没有直接指定这些属性的值（参考<a href="https://dev.opera.com/articles/css-will-change-property/" target="_blank" rel="noopener">这篇文章</a>）</li>
<li>-webkit-overflow-scrolling 属性被设置 “touch”的元素</li>
</ul>
<p>也就是说，上面例子中， <code>.dog-container</code> 满足上面任意一条属性，也会一样出现上面的情况。比如设置 opacity 属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.dog-container &#123;</span><br><span class="line">  width: 200px;</span><br><span class="line">  height: 100px;</span><br><span class="line">  background: red;</span><br><span class="line">  position: relative;</span><br><span class="line">  opacity: 0.6; /* 设置 opacity 属性小于1也会创建层叠上下文 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/10350345-55ccf07f3486a556.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="z-index"></p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ol>
<li>z-index 属性用于描述定位元素在垂直于页面方向上的排列顺序。</li>
<li>z-index 一般比较规则是值大在上，值相同则排后面的在上。</li>
<li>元素在设置了某些属性的时候会创建层叠上下文，z-index 值比较大小只有在同一个层叠上下文才有效。</li>
</ol>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="http://www.zhangxinxu.com/wordpress/2016/01/understand-css-stacking-context-order-z-index/" target="_blank" rel="noopener">深入理解CSS中的层叠上下文和层叠顺序</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index" target="_blank" rel="noopener">理解CSS的 z-index属性</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context" target="_blank" rel="noopener">层叠上下文-MDN</a></li>
</ul>
<h1 id="flexbox-剩余空间分配规则"><a href="#flexbox-剩余空间分配规则" class="headerlink" title="flexbox 剩余空间分配规则"></a>flexbox 剩余空间分配规则</h1><p>前面我们学习到了 flexbox 布局。通过使用 flexbox 布局，我们可以更轻松实现以往很难实现的页面布局。本文主要讲解 flexbox 布局是如何去分配和计算布局剩余空间的。（本文阅读前要求你对 flexbox 已经有了初步的认知，如果不是很了解，建议先学习前面视频内容。）</p>
<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>为了更好地理解本文内容，我们需要先了解下面一些基础概念。</p>
<h3 id="flexbox-容器-flexbox-container"><a href="#flexbox-容器-flexbox-container" class="headerlink" title="flexbox 容器 (flexbox container)"></a>flexbox 容器 (flexbox container)</h3><p>flexbox 容器又称弹性容器，通过设置 <code>display: flex</code> 而产生，简单示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  display: flex; /* 或者 inline-flex */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="flexbox-项目-flexbox-item）"><a href="#flexbox-项目-flexbox-item）" class="headerlink" title="flexbox 项目 (flexbox item）"></a>flexbox 项目 (flexbox item）</h3><p>当设置一个元素为 flexbox 容器时，其直接子元素将自动成为容器成员，也可以称之为：flexbox 项目。</p>
<p>注：因为 flexbox 布局是发生在父元素和子元素之间的，所以下面为了行文方便，统一将 flexbox 容器称为“父容器”，而 flexbox 项目统一称为“子元素”</p>
<h3 id="剩余空间"><a href="#剩余空间" class="headerlink" title="剩余空间"></a>剩余空间</h3><p>剩余空间就是指父容器在主轴方向上剩余未分配的空间，它是 flexbox 布局中一个很重要的词。我们可以借助下面的例子来更好地理解：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/10350345-daac84b0f490ab5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;container&quot; width=&quot;600px&quot; style=&quot;display:flex;&quot;&gt;</span><br><span class="line">  &lt;span class=&quot;item1&quot; width=&quot;200px&quot;&gt;item1&lt;/span&gt;</span><br><span class="line">  &lt;span class=&quot;item2&quot; width=&quot;200px&quot;&gt;item2&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>上面代码，我们定义了一个宽度为600px的父容器 container，以及宽度为200px的子元素 item1 和 item2 ，那么我们得出其剩余空间为200px，计算公式为：</p>
<p><code>剩余空间 = 父容器的宽度 - item1的宽度 - item2的宽度</code></p>
<h2 id="剩余空间分配相关属性"><a href="#剩余空间分配相关属性" class="headerlink" title="剩余空间分配相关属性"></a>剩余空间分配相关属性</h2><p>flexbox 布局中的子元素可以通过设置 <code>flex</code> 属性来改变其所分配到的空间大小。<code>flex</code> 属性包括了 <code>flex-basis</code>、 <code>flex-grow</code>、<code>flex-shrink</code></p>
<h3 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h3><p>flex-basis 用来定义子元素的默认宽或高。如果父容器 <code>flex-direction</code> 属性的方向为水平方向则为宽度，如为垂直方向则为高度。相当于给子元素设置宽或高。如果同时设置了该属性与宽或高，则该属性权重大于宽或高的值。</p>
<h3 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h3><p>flex-grow 用来指定父容器多余空间的分配比率，默认值为0。看到这里，大家可能还是没有概念。为了更形象地理解，我们一起看下下面的例子。</p>
<h4 id="例子：-只设置-item1-的-flex-grow-为1"><a href="#例子：-只设置-item1-的-flex-grow-为1" class="headerlink" title="例子： 只设置 item1 的 flex-grow 为1"></a>例子： 只设置 item1 的 flex-grow 为1</h4><p><img src="http://upload-images.jianshu.io/upload_images/10350345-337eb4ed0c4c4904.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>其 HTML 代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">  &lt;span class=&quot;item item-flex-grow&quot;&gt;item1&lt;/span&gt;</span><br><span class="line">  &lt;span class=&quot;item item2&quot;&gt;item2&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>其 CSS 代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/* css 部分 */</span><br><span class="line">.container &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  width: 600px;</span><br><span class="line">  height: 140px;</span><br><span class="line">  align-items: center;</span><br><span class="line">  background-color: #ddd;</span><br><span class="line">&#125;</span><br><span class="line">.item &#123;</span><br><span class="line">  width: 200px;</span><br><span class="line">  height: 120px;</span><br><span class="line">  line-height: 120px;</span><br><span class="line">  text-align: center;</span><br><span class="line">  background-color: orange;</span><br><span class="line">&#125;</span><br><span class="line">.item2 &#123;</span><br><span class="line">  background-color: green;</span><br><span class="line">&#125;</span><br><span class="line">.item-flex-grow&#123;</span><br><span class="line">  flex-grow:1;</span><br><span class="line">  background-color: </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们对 item1 设置<code>flex-grow:1</code> 后，我们可以看到 item1 的所占空间宽度变成400px，也就是说 item1 把之前我们所说的父容器剩余的200px空间都占用了。</p>
<p>在这里我们可以得出：<strong>其实 flex-grow 即定义如何去分配父容器的剩余空间</strong> ，当值为0时，则子元素都不会索取父容器的剩余空间。当 item1 设置 <code>flex-grow: 1</code> 的时候，由于 item2 没有设置 flex-grow 的值，则剩余空间将会被分成一份，并且分别分给了 item1。</p>
<h4 id="例子：-设置-item1-的-flex-grow-为1，且-item2-的-flex-grow-为3"><a href="#例子：-设置-item1-的-flex-grow-为1，且-item2-的-flex-grow-为3" class="headerlink" title="例子： 设置 item1 的 flex-grow 为1，且 item2 的 flex-grow 为3"></a>例子： 设置 item1 的 flex-grow 为1，且 item2 的 flex-grow 为3</h4><p>如果此时我们设置 item2 的<code>flex-grow:3</code> ，item2 也将会参与索取父容器的剩余空间，此时父容器的剩余空间将分为4份，然后1份分配到 item1，而分配3份到 item2，如下图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/10350345-138d0c51a5e11840.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h4 id="如果子元素的宽度的总和超过父容器，flex-grow-将不生效。"><a href="#如果子元素的宽度的总和超过父容器，flex-grow-将不生效。" class="headerlink" title="如果子元素的宽度的总和超过父容器，flex-grow 将不生效。"></a>如果子元素的宽度的总和超过父容器，flex-grow 将不生效。</h4><p>上面的例子，我们只考虑了子元素的宽度总和都是没有超过父容器的宽度的情况，则其可以使用 flex-grow 来分配父容器的剩余空间。那么当子元素的宽度总和超过父容器的宽度时，这时剩余空间还可以分配吗？此时 flex-grow 是否还有效呢？让我们先看看下面的例子：</p>
<p>这里我们设置上面例子的 item1 和 item2 的宽度为350px，则子元素的宽度总和为700px且超过父容器container的600px宽度。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/10350345-626859657d98fd49.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>我们可以看到 flex-grow 并没有起到作用，且两个 item 的宽度还被压缩到只有300px。</p>
<p>通过之前学到的如何计算剩余空间的方法，我们可以算出本例子的剩余空间为600px - 700px即 -100px,这里可以得出由于没有剩余空间，则定义了 flex-grow 的子元素能分配到的空间为0，故不生效。另外我们需要知道的是 flexbox 环境的父容器的宽度600px并不会因为子元素的总宽而改变，即子元素的宽度总和最多等于父容器的宽度，所以为了让子元素完整显示在父容器内，只有两个办法：</p>
<ul>
<li>通过设置 flex-wrap 来使子元素换行</li>
<li>通过压缩子元素来使其能容纳在父容器内</li>
</ul>
<h3 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h3><p>flex-shrink 用来指定父容器空间不够时子元素的缩小比例，默认为1。如果一个 flexbox 项目的 flex-shrink 属性为0，则该元素不会被压缩。</p>
<h4 id="为什么需要-flex-shrink-来定义缩小比例呢？"><a href="#为什么需要-flex-shrink-来定义缩小比例呢？" class="headerlink" title="为什么需要 flex-shrink 来定义缩小比例呢？"></a>为什么需要 flex-shrink 来定义缩小比例呢？</h4><p>上面我们可以知道，当子元素的宽度总和大于 flexbox 父容器的宽度时，其剩余空间将为负数，如果没有设置换行的情况下，其将会通过压缩子元素来使其能够容纳在父容器内。那么我们如何控制子元素的压缩比例呢？答案就是通过将通过设置 <code>flex-shrink</code> 这个属性。</p>
<h4 id="例子：设置项目的flex-shrink"><a href="#例子：设置项目的flex-shrink" class="headerlink" title="例子：设置项目的flex-shrink"></a>例子：设置项目的flex-shrink</h4><p>下面例子，我们设置两个 item 的宽度为350px，而容器 container 的宽度仍为600px。同时定义了 item1 和 item2 的 flex-shrink 的属性分别为1和4。如下所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/10350345-d597916c63587fcb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/* 这里只展示关键css */</span><br><span class="line">.container &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  width: 600px;</span><br><span class="line">  height: 140px;</span><br><span class="line">&#125;</span><br><span class="line">.item &#123;</span><br><span class="line">  width: 350px;</span><br><span class="line">  height: 120px;</span><br><span class="line">&#125;</span><br><span class="line">.item1 &#123;</span><br><span class="line">  flex-shrink: 1;</span><br><span class="line">&#125;</span><br><span class="line">.item2&#123;</span><br><span class="line">  flex-shrink: 4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到由于缺少100px的空间，按照 item1 和 item2 定义的 flex-shrink 的值，缺少的100px将分成5份。item1 将压缩其中的 1/5 即20px，item2 的将压缩其中的 4/5 即80px。</p>
<h4 id="例子：设置项目的-flex-shrink-为0"><a href="#例子：设置项目的-flex-shrink-为0" class="headerlink" title="例子：设置项目的 flex-shrink 为0"></a>例子：设置项目的 flex-shrink 为0</h4><p>在上面的知识中，我们了解到 flex-shrink 默认值为1，即默认子元素在父容器空间不足时会被压缩。现在我们把项目的 flex-shrink 设为0来看下不压缩的情况。如下所示：</p>
<p>[图片上传中…(image-22b3f3-1542962334288-0)]</p>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/* 这里只展示关键css */</span><br><span class="line">.container &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  width: 600px;</span><br><span class="line">  height: 140px;</span><br><span class="line">&#125;</span><br><span class="line">.item &#123;</span><br><span class="line">  width: 350px;</span><br><span class="line">  height: 120px;</span><br><span class="line">  flex-shrink: 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="更多阅读-1"><a href="#更多阅读-1" class="headerlink" title="更多阅读"></a>更多阅读</h2><ul>
<li><a href="http://coding.imweb.io/demo/p3/flexbox-sizerule.html" target="_blank" rel="noopener">flex 计算规则在线demo</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/flex" target="_blank" rel="noopener">Flex MDN</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">Flex 布局教程：语法篇</a></li>
</ul>
<h1 id="grids-布局系统"><a href="#grids-布局系统" class="headerlink" title="grids 布局系统"></a>grids 布局系统</h1><p>我们之前有提到过网格系统，比如<a href="http://960.gs/" target="_blank" rel="noopener">960s</a>，<a href="https://v4-alpha.getbootstrap.com/layout/grid/" target="_blank" rel="noopener">bootstrap</a> 的网格系统，但是这些网格系统都是模拟出来的（使用 float 或 flexbox），而并非天生的，虽然可以解决一些常见布局问题，但面临 Win10 UI 还是有点力所不及，如下图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/10350345-9b6edc5b186b2e56.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>但是随着 CSS 的不断发展及完善，一种新的网格布局方式被纳入规范，它将会解决所有的网格问题，这就是我们要说的 CSS Grid Layout。</p>
<h2 id="网格系统基础概念"><a href="#网格系统基础概念" class="headerlink" title="网格系统基础概念"></a>网格系统基础概念</h2><p>在说 CSS Grid Layout 之前，我们先来看看 excel 的表格。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/10350345-669993d92974b0d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="excel css gri layout"></p>
<p>以我们的 Sheet1 的 A1 单元格为例，先是有上下左右四条线围着，然后定位是由竖直的 A 栏与横向的1行二维坐标表示 A1。如果有需要甚至还还可以和邻近的单元格合并。</p>
<p>现在我们提炼下上面的几个概念：线条，栏(竖直)，行(横向)，单元格，合并。接下来我们把这些概念对应到我们的网格系统：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/10350345-05e6311f6ac9263e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="CSS Grid Layout"></p>
<ul>
<li>Grid Container：首先我们要设置父元素的布局为 grid，通过使用 display 属性给元素显式设置属性值grid或inline-grid，此时这个元素将自动变成网格容器，对应上图的Sheet1</li>
<li>Grid Item：Item 是 container 的直接子元素，如果不考虑单元格的合并跟下面的 cell 是一样的，如果有单元格合并，在该 item 可能包括几个cell，对应上图的一个个格子，如蓝色的 A1</li>
<li>Grid Lines：网格线分为水平线和垂直线，对应上图的橙色线条</li>
<li>Grid Track：就是由lines构成的水平和垂直空间，对应到上图的水平和垂直灰色区域，而对于table来说就是row和column</li>
<li>Grid Cell：简单来说就是单元格了，对应到上图就是蓝色的A1，而对于table来说就是单元格</li>
<li>Grid Area：网格区域是由任意四条网格线组成的空间，可能由一个或多个单元格组成。对应到上图就是红色区域，相当于表格中的合并单元格之后的区域</li>
</ul>
<h2 id="网格系统基本属性"><a href="#网格系统基本属性" class="headerlink" title="网格系统基本属性"></a>网格系统基本属性</h2><p>网格系统布局其实跟 flexbox 布局差不多，都是由父子元素构成的布局。所以属性分为父元素属性和子元素属性。</p>
<p>因篇幅有限，这里只简单介绍每个属性的用途，具体的属性取值请参考：</p>
<ul>
<li><a href="https://css-tricks.com/snippets/css/complete-guide-grid/#prop-align-items" target="_blank" rel="noopener">A Complete Guide to Grid</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/grid" target="_blank" rel="noopener">grid | MDN</a></li>
</ul>
<h3 id="父元素（Grid-Container）属性"><a href="#父元素（Grid-Container）属性" class="headerlink" title="父元素（Grid Container）属性"></a>父元素（Grid Container）属性</h3><p>这里我们将父元素属性大概分为三大类，其中第一类与第二类属性可以简写为 <code>grid</code> 属性（不包括 <code>display</code> 属性）：</p>
<p>第一类：如何去定义一个网格系统，行列及间距等。</p>
<ul>
<li>display：grid/inline-grid，定义使用网格系统</li>
<li>grid-template-columns：定义垂直栏</li>
<li>grid-template-rows：定义水平行</li>
<li>grid-template-areas：定义区域</li>
<li>grid-column-gap：定义垂直栏与垂直栏之间的间距，如上图的A与B之间的间距</li>
<li>grid-row-gap：定义水平行与水平行之间的间距，如上图的1与2之间的间距</li>
<li>grid-gap：上面两个栏与行间距的缩写</li>
</ul>
<p>第二类：自动分配形式，当定义的行或列数量不够时，多出 item 的自动排列方式：</p>
<ul>
<li>grid-auto-columns：定义多出的 item 的自动column的宽度大小</li>
<li>grid-auto-rows：定义多出的 item 自动 row 的高度大小</li>
<li>grid-auto-flow：定义自动 item 是按照先水平方向排列还是垂直方向排列</li>
</ul>
<p>第三类：分布对齐的方式（属性跟 flexbox 的有点像）。</p>
<ul>
<li>justify-items：item 在水平行中的对齐方式</li>
<li>align-items：item 在垂直栏中的对齐方式</li>
<li>justify-content：整个水平行在 grid 范围的对齐方式，这里有个好用的 <code>space-evenly</code> 值，补足了以前flex的 <code>space-around</code> 和 <code>space-between</code> 的不足</li>
<li>align-content：整个垂直栏在 grid 范围的对齐方式</li>
</ul>
<h3 id="子元素（Grid-Item）属性"><a href="#子元素（Grid-Item）属性" class="headerlink" title="子元素（Grid Item）属性"></a>子元素（Grid Item）属性</h3><p>接下来是我们的 item 属性，同样这里我也将它分为两类：</p>
<p>第一类：单元格所占格子多少</p>
<ul>
<li>grid-column-start：item 的起始栏</li>
<li>grid-column-end：item 的结束栏</li>
<li>grid-column：起始栏和结束栏的简写</li>
<li>grid-row-start：item 的起始行</li>
<li>grid-row-end：item 的结束行</li>
<li>grid-row：起始行与结束行的简写</li>
<li>grid-area：item所在区域</li>
</ul>
<p>第二类：单元格的自定义对齐方式，这个跟 flexbox 的 item 有点相似。</p>
<ul>
<li>justify-self：自定义 item 的水平方向对齐方式</li>
<li>align-self：自定义 item 的垂直方向对齐方式</li>
</ul>
<h2 id="实例演示"><a href="#实例演示" class="headerlink" title="实例演示"></a>实例演示</h2><p>百说不如一练，我们接下来使用网格系统来实战下我们的 Win10 UI，如下图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/10350345-7af4d4f1d812db95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="grids demo"></p>
<p>)</p>
<p>html结构为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;grid&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;item&quot;&gt;1&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;item&quot;&gt;2&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;item&quot;&gt;3&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;item&quot;&gt;4&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;item&quot;&gt;5&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;item&quot;&gt;6&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;item&quot;&gt;7&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;item&quot;&gt;8&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;item&quot;&gt;9&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;item&quot;&gt;10&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;item&quot;&gt;11&lt;/div&gt;</span><br><span class="line">&lt;/div</span><br></pre></td></tr></table></figure>
<p>写好结构后，我们就开始使用刚才说得 grid 来实现我们的效果了。先拆分成最小的单元格为 6栏 * 3行，最小单元格的大小为140px，整体内容一屏水平垂直居中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">html,body &#123;</span><br><span class="line"> height: 100%;</span><br><span class="line">&#125;</span><br><span class="line">.grid &#123;</span><br><span class="line">  height: 100%;</span><br><span class="line">  display: grid; /* 网格布局 */</span><br><span class="line"></span><br><span class="line">  /* 整体水平垂直居中 */</span><br><span class="line">  justify-content: center;</span><br><span class="line">  align-content: center;</span><br><span class="line"></span><br><span class="line">  /* 定义6栏3行 */</span><br><span class="line">  grid-template-columns: 140px 140px 140px 140px 140px 140px;</span><br><span class="line">  grid-template-rows: 140px 140px 140px;</span><br><span class="line"></span><br><span class="line">  /* 定义item之间的间距为20px */</span><br><span class="line">  grid-gap: 20px;</span><br><span class="line"></span><br><span class="line">  background: #efefef;</span><br><span class="line">&#125;</span><br><span class="line">.item&#123;</span><br><span class="line">  background: #ccc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们可以看到效果如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/10350345-b8f3a0ca6658ac62.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>接下来要合并单元格实现我们的最终效果。合并单元格有两种实现方式一种是 line 的开始与结束（包括 colunm 与 row），另一种就是在 grid 上面定义的 area，这里我们使用第一种方法。</p>
<p>这里重提下上面的 Grid Lines 概念，如要实现 n栏 * m行的网格，则需要n+1条垂直line，m+1条水平线。</p>
<p>第一个 item 元素单元格占了两列，第一列和第二列，那么就垂直栏开始于第一条 line，结束于第三条 line，同样第5个 item 元素也是如此</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.item:nth-child(1),</span><br><span class="line">.item:nth-child(5) &#123;</span><br><span class="line">  grid-column: 1 / 3; /* 起始于1，结束于3 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而第二个 item 元素栏和行都跨了两个，CSS 代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.item:nth-child(2) &#123;</span><br><span class="line">  grid-column: 3 / 5; /* column起始于3，结束于5 */</span><br><span class="line">  grid-row: 1 / 3;  /* row起始于1，结束于3 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样第七个 item 元素行跨了两个，第9个 item 元素栏跨了两个，CSS 代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.item:nth-child(7) &#123;</span><br><span class="line">  grid-column: 6;</span><br><span class="line">  grid-row: 2 / 4; /* row起始于2，结束于4 */</span><br><span class="line">&#125;</span><br><span class="line">.item:nth-child(9) &#123;</span><br><span class="line">  grid-column: 2 / 4; /* column起始于2，结束于4 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个布局就这么简单的完成了，效果可见 <a href="http://coding.imweb.io/demo/p3/grid.html" target="_blank" rel="noopener">demo</a></p>
<h2 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h2><p>现代浏览器最新版本基本上都支持了 CSS Grid Layout，下图是 <a href="http://caniuse.com/#search=grid" target="_blank" rel="noopener">caniuse</a> 上的支持情况：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/10350345-4779ab0912dc1970.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="caniuse"></p>
<p>有些浏览器旧版本的已经实现但是没有默认开启（chrome &lt; 57，firefox &lt; 52）则需要通过下面的方式手动设置开启：</p>
<ul>
<li>chrome 在地址栏输入“chrome://flags”，找到”experimental web platform features”开启</li>
<li>firefox在地址栏输入”about:config”，找到”layout.css.grid.enabled”开启</li>
</ul>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>上面只是 grid 布局的简单使用，实际上 grid 布局十分强大，使用起来也十分方便，未来将会是布局的主力军，但是目前由于兼容问题暂时不建议在生产环境中使用，不过我们相信很快就可以见识到 grid 布局的强大威力了。</p>
<h2 id="参考资料-1"><a href="#参考资料-1" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://css-tricks.com/snippets/css/complete-guide-grid/#prop-align-items" target="_blank" rel="noopener">A Complete Guide to Grid</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout" target="_blank" rel="noopener">CSS Grid Layout</a></li>
</ul>
<h1 id="浏览器如何渲染-HTML-amp-CSS"><a href="#浏览器如何渲染-HTML-amp-CSS" class="headerlink" title="浏览器如何渲染 HTML &amp; CSS"></a>浏览器如何渲染 HTML &amp; CSS</h1><p>我们现在已经知道，使用 HTML &amp; CSS 可以搭建出一个漂亮的 Web 页面。</p>
<p>那么浏览器到底是如何使用我们的 HTML &amp; CSS 渲染成我们在屏幕上所看到的页面呢？</p>
<p>虽然具体渲染过程很复杂，但是还是可以将其分为几个关键路径，如下：</p>
<ul>
<li>处理 HTML 标记并构建 DOM 树</li>
<li>处理 CSS 标记并构建 CSSOM 树</li>
<li>将 DOM 与 CSSOM 合并成一个渲染树</li>
<li>根据渲染树来布局，以计算每个节点的几何信息，再将各个节点绘制到屏幕上</li>
</ul>
<h2 id="构建-DOM-树"><a href="#构建-DOM-树" class="headerlink" title="构建 DOM 树"></a>构建 DOM 树</h2><p>首先浏览器渲染页面前会根据 HTML 结构构建成对应的 DOM 树。</p>
<p>以下面的 HTML 代码为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;</span><br><span class="line">    &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot;&gt;</span><br><span class="line">    &lt;title&gt;Critical Path&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;p&gt;Hello &lt;span&gt;web performance&lt;/span&gt; students!&lt;/p&gt;</span><br><span class="line">    &lt;div&gt;&lt;img src=&quot;awesome-photo.jpg&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>其 DOM 树生成的流程如下图：</p>
<p>[图片上传中…(image-b05031-1542962693660-5)]</p>
<ol>
<li>转换： 浏览器从磁盘或网络读取 HTML 的原始字节，并根据文件的指定编码（例如 UTF-8）将它们转换成各个字符。</li>
<li>令牌化： 浏览器将字符串转换成 W3C HTML5 标准规定的各种令牌，例如，“”、“”，以及其他尖括号内的字符串。每个令牌都具有特殊含义和一组规则。</li>
<li>词法分析： 发出的令牌转换成定义其属性和规则的“对象”。</li>
<li>DOM 构建： 最后，由于 HTML 标记定义不同标记之间的关系（一些标记包含在其他标记内），创建的对象链接在一个树数据结构内，此结构也会捕获原始标记中定义的父项-子项关系：HTML 对象是 body 对象的父项，body 是 paragraph 对象的父项，依此类推。</li>
</ol>
<p>整个流程的最终输出就是我们这个简单页面的文档对象模型 (DOM)，如下图：</p>
<p>[图片上传中…(image-2b953-1542962693660-4)]</p>
<h3 id="CSSOM"><a href="#CSSOM" class="headerlink" title="CSSOM"></a>CSSOM</h3><p>在浏览器构建上面的 DOM 时，在文档的 head 部分遇到了一个 link 标记，该标记引用一个外部 CSS 样式表：<code>style.css</code>。由于预见到需要利用该资源来渲染页面，它会立即发出对该资源的请求，并返回以下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* style.css */</span><br><span class="line"></span><br><span class="line">body &#123; font-size: 16px &#125;</span><br><span class="line">p &#123; font-weight: bold &#125;</span><br><span class="line">span &#123; color: red &#125;</span><br><span class="line">p span &#123; display: none &#125;</span><br><span class="line">img &#123; float: right &#125;</span><br></pre></td></tr></table></figure>
<p>与处理 HTML 时一样，我们需要将收到的 CSS 规则转换成某种浏览器能够理解和处理的东西。因此，我们会重复 HTML 过程，不过是为 CSS 而不是 HTML：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/10350345-bf30225adc0ec624.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>CSS 字节转换成字符，接着转换成令牌和节点，最后挂靠到一个称为“CSS 对象模型”(CSSOM) 的树结构内：</p>
<p>[图片上传中…(image-d167f0-1542962693660-2)]</p>
<p>CSSOM 为何具有树结构？这是因为浏览器为页面上的任何对象计算最后一组样式时，都会先从适用于该节点的最通用规则开始（例如，如果该节点是 body 元素的子项，则应用所有 body 样式），然后通过应用更具体的规则（即规则“向下级联”）以递归方式优化计算的样式。</p>
<p>以上面的 CSSOM 树为例进行更具体的阐述。span 标记内包含的任何置于 body 元素内的文本都将具有 16 像素字号，并且颜色为红色 — font-size 指令从 body 向下级联至 span。不过，如果某个 span 标记是某个段落 (p) 标记的子项，则其内容将不会显示。</p>
<h2 id="合并渲染树"><a href="#合并渲染树" class="headerlink" title="合并渲染树"></a>合并渲染树</h2><p>接下来就是将 DOM 树与 CSSOM 树合并形成渲染树。</p>
<p>渲染树会网罗网页上所有可见的 DOM 内容，以及每个节点的所有 CSSOM 样式信息。</p>
<p>[图片上传中…(image-293e8f-1542962693660-1)]</p>
<p>注：渲染树只包含渲染网页所需的节点，如<code>display: none;</code>的元素是不会出现在渲染树种的。</p>
<h2 id="布局及绘制"><a href="#布局及绘制" class="headerlink" title="布局及绘制"></a>布局及绘制</h2><p>有了渲染树，我们就可以进入“布局”阶段。</p>
<p>到目前为止，我们计算了哪些节点应该是可见的以及它们的计算样式，但我们尚未计算它们在设备视口内的确切位置和大小—这就是“布局”阶段，也称为“自动重排”。</p>
<p>为弄清每个对象在网页上的确切大小和位置，浏览器从渲染树的根节点开始进行遍历。让我们考虑下面这样一个简单的实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;</span><br><span class="line">    &lt;title&gt;Critial Path: Hello world!&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div style=&quot;width: 50%&quot;&gt;</span><br><span class="line">      &lt;div style=&quot;width: 50%&quot;&gt;Hello world!&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>以上网页的正文包含两个嵌套 div：第一个（父）div 将节点的显示尺寸设置为视口宽度的 50%；而里面内嵌的第二个 div 将其宽度设置为其父项的 50%，即视口宽度的 25%。如下图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/10350345-afe8c62eeb72d8d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>布局流程的输出是一个“盒模型”，它会精确地捕获每个元素在视口内的确切位置和尺寸：所有相对测量值都转换为屏幕上的绝对像素。</p>
<p>最后，既然我们知道了哪些节点可见、它们的计算样式以及几何信息，我们终于可以将这些信息传递给最后一个阶段：将渲染树中的每个节点转换成屏幕上的实际像素形成我们可见的页面。这一步通常称为“绘制”或“栅格化”。</p>
<p>注：执行渲染树构建、布局和绘制所需的时间将取决于文档大小、应用的样式，以及运行文档的设备：文档越大，浏览器需要完成的工作就越多；样式越复杂，绘制需要的时间就越长（例如，单色的绘制开销“较小”，而阴影的计算和渲染开销则要“大得多”）。</p>
<h2 id="参考资料-2"><a href="#参考资料-2" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/" target="_blank" rel="noopener">关键渲染路径</a></li>
</ul>
<h1 id="重排与重绘"><a href="#重排与重绘" class="headerlink" title="重排与重绘"></a>重排与重绘</h1><p>一个页面渲染完毕后，随着用户的操作，或者数据变化，网页还会进行重新渲染。根据不同的触发条件，重新渲染分为两种情况：重排（reflow）和重绘（repaint）。</p>
<p>所有对元素视觉表现属性的修改，都会导致重绘（repaint）。比如修改了背景颜色、文字颜色等。</p>
<p>所有会触发元素布局发生变化的修改，都会导致重排（reflow）。比如窗口尺寸发生变化，删除、添加 DOM 元素，修改了影响元素盒子大小的 CSS 属性如 <code>width</code>、 <code>height</code>、 <code>padding</code> 等。</p>
<p>通常情况下，重排的影响更大，重排会导致文档局部或全部的重新运算：重新计算元素位置，大小。（改变一个元素的布局，可能会影响很多个元素的布局）</p>
<p>不管是重绘还是重排导致的重新渲染，都会阻塞浏览器。重新渲染的的过程中，JavaScript 会被阻塞，用户的交互行为也会被卡住。复杂的 CSS 动画甚至会拖慢 JavaScript 的运行速度。</p>
<p>注：本文涉及到的 JavaScript 部分，可以先忽略，等以后学习了 JavaScript 再来查看。</p>
<h2 id="导致重排和重绘的场景"><a href="#导致重排和重绘的场景" class="headerlink" title="导致重排和重绘的场景"></a>导致重排和重绘的场景</h2><h3 id="CSS-属性改变"><a href="#CSS-属性改变" class="headerlink" title="CSS 属性改变"></a>CSS 属性改变</h3><p>网站 <a href="https://csstriggers.com/" target="_blank" rel="noopener">CSS trigglers</a> 列出了所有 CSS 属性对 layout （布局）、paint （绘制）的影响。通过这个表，可以查到不同内核下，对 CSS 属性的修改会导致重绘、重排还是两者都会发生。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/10350345-083303b8092ebd7b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="re-render"></p>
<p>注：Composite （渲染层合并） 是 chrome 引入 GPU 加速带来的新概念。（相关信息可参看下面的参看资料）</p>
<p>对 CSS 属性进行修改，包括但不限于以下场景：</p>
<ul>
<li>通过 <code>display: none</code> 隐藏 DOM 节点（导致重绘和重排）</li>
<li>通过 <code>visibility: hidden</code> 隐藏 DOM 节点 （导致重绘，因为它没有影响其它元素位置布局）</li>
<li>CSS 动画</li>
<li>通过 JavaScript 添加样式，修改样式</li>
</ul>
<h3 id="用户交互"><a href="#用户交互" class="headerlink" title="用户交互"></a>用户交互</h3><ul>
<li>对浏览器窗口进行缩放操作会导致重排</li>
<li>对 DOM 节点进行操作，添加、删除、更新 DOM 节点都会导致重排</li>
<li>光标 <code>:hover</code> 、进入文本输入框、修改浏览器的字体都会导致重排</li>
</ul>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>所有的最佳实践都是围绕尽最大可能的降低重绘和重排的频率，来达到减少重新渲染的目的。</p>
<h3 id="CSS-属性的读、写操作分开"><a href="#CSS-属性的读、写操作分开" class="headerlink" title="CSS 属性的读、写操作分开"></a>CSS 属性的读、写操作分开</h3><p>浏览对 CSS 属性的连续修改做了优化，比如下面的连续修改两次 style，不会导致两次重新渲染：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">div.style.color = &apos;blue&apos;;</span><br><span class="line">div.style.marginTop = &apos;30px&apos;;</span><br></pre></td></tr></table></figure>
<p>上面代码只会进行一次重新渲染。但是如果写的不好，则会触发两次重新渲染，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div.style.color = &apos;blue&apos;;</span><br><span class="line">var margin = parseInt(div.style.marginTop);</span><br><span class="line">div.style.marginTop = (margin + 10) + &apos;px&apos;;</span><br></pre></td></tr></table></figure>
<p>上面代码对 div 元素设置背景色以后，第二行要求浏览器给出该元素的位置，所以浏览器不得不重新渲染然后得到该元素的位置。</p>
<p>除此之外，样式的写操作之后，如果有下面这些属性的读操作，都会引发浏览器立即重新渲染：</p>
<ul>
<li><code>offsetTop/offsetLeft/offsetWidth/offsetHeight</code></li>
<li><code>scrollTop/scrollLeft/scrollWidth/scrollHeight</code></li>
<li><code>clientTop/clientLeft/clientWidth/clientHeight</code></li>
<li><code>getComputedStyle()</code></li>
</ul>
<h3 id="通过-class-或者-csstext-来批量更新样式"><a href="#通过-class-或者-csstext-来批量更新样式" class="headerlink" title="通过 class 或者 csstext 来批量更新样式"></a>通过 class 或者 csstext 来批量更新样式</h3><p>上面对通过对 style 对 CSS 属性一个一个修改，其实更好的方式应该是通过 class 来批量化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line">var left = 10;</span><br><span class="line">var top = 10;</span><br><span class="line">el.style.left = left + &quot;px&quot;;</span><br><span class="line">el.style.top  = top  + &quot;px&quot;;</span><br><span class="line"></span><br><span class="line">// good </span><br><span class="line">el.className += &quot; theclassname&quot;;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">el.style.cssText += &quot;; left: &quot; + left + &quot;px; top: &quot; + top + &quot;px;&quot;;</span><br></pre></td></tr></table></figure>
<h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><ul>
<li>DOM 样式离线更新：尽量使用离线 DOM，而不是真实的网页 DOM 来改变元素样式。比如，操作 Document Fragment对象，完成后再把这个对象加入 DOM。再比如，使用 cloneNode() 方法，在克隆的节点上进行操作，然后再用克隆的节点替换原始节点。</li>
<li>使用 <code>display: none</code> 进行样式批量更新：先将元素设为 <code>display: none</code>（需要1次重排和重绘），然后对这个节点进行100次操作，最后再恢复显示（需要1次重排和重绘）。这样一来，你就用两次重新渲染，取代了可能高达100次的重新渲染。</li>
<li>善用 position：<code>position</code> 属性为 <code>absolute</code> 或 <code>fixed</code> 的元素，重排的开销会比较小，因为不用考虑它对其他元素的影响。</li>
<li>将元素设置为不可见：只在必要的时候，才将元素的 display 属性为可见，因为不可见的元素不影响重排和重绘。另外，<code>visibility : hidden</code> 的元素只对重绘有影响，不影响重排。</li>
<li>减少样式的更新频率：使用虚拟 DOM 脚本库，比如 React 等。</li>
<li>调节 js 运行帧率：使用 window.requestAnimationFrame()、window.requestIdleCallback() 这两个方法调节重新渲染的频率。</li>
<li>慎用 table 布局：table 的单元格具有非常好的自适应特性，但是同时代价也很高，能不用就不用。如果非要使用 table ，给 table 添加 <code>table-layout: fixed</code> 属性，这个属性的目的是让后面单元格的宽度由表头的宽度来决定——减少布局的计算量。</li>
</ul>
<h2 id="参看资料"><a href="#参看资料" class="headerlink" title="参看资料"></a>参看资料</h2><ul>
<li><a href="http://www.ruanyifeng.com/blog/2015/09/web-page-performance-in-depth.html" target="_blank" rel="noopener">网页性能管理详解</a></li>
<li><a href="https://www.sitepoint.com/10-ways-minimize-reflows-improve-performance" target="_blank" rel="noopener">10 Ways to Minimize Reflows and Improve Performance</a></li>
<li><a href="http://taobaofed.org/blog/2016/04/25/performance-composite/" target="_blank" rel="noopener">无线性能优化：Composite</a></li>
<li><a href="http://www.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome" target="_blank" rel="noopener">gpu-accelerated-compositing-in-chrome</a></li>
</ul>
<h1 id="水平垂直居中技术"><a href="#水平垂直居中技术" class="headerlink" title="水平垂直居中技术"></a>水平垂直居中技术</h1><p>该技术是常用技术，也是面试易考点，所以掌握它很有必要。下面是一些总结文章，大家可以参考：</p>
<ul>
<li><a href="https://www.w3cplus.com/css/centering-css-complete-guide.html" target="_blank" rel="noopener">CSS居中完整指南</a>（中文版）</li>
<li><a href="https://css-tricks.com/centering-css-complete-guide/" target="_blank" rel="noopener">Centering in CSS: A Complete Guide</a>（英文版）</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/01/17/前端知识归纳（2）-CSS基础/" rel="next" title="前端知识归纳（2）-- CSS基础">
                <i class="fa fa-chevron-left"></i> 前端知识归纳（2）-- CSS基础
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/01/17/前端知识归纳（3）-HTML-CSS（part2-CSS动画）/" rel="prev" title="前端知识归纳（3）-- HTML/CSS（part2 CSS动画）">
                前端知识归纳（3）-- HTML/CSS（part2 CSS动画） <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Sponge</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">31</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#深入理解-HTML-语义"><span class="nav-number">1.</span> <span class="nav-text">深入理解 HTML 语义</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#从“文档”说起"><span class="nav-number">1.1.</span> <span class="nav-text">从“文档”说起</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#文档大纲"><span class="nav-number">1.1.1.</span> <span class="nav-text">文档大纲</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#再来看“万维网”"><span class="nav-number">1.2.</span> <span class="nav-text">再来看“万维网”</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#现在才到-HTML-语义"><span class="nav-number">1.3.</span> <span class="nav-text">现在才到 HTML 语义</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#让-IE8-支持-HTML5-语义化标签"><span class="nav-number">2.</span> <span class="nav-text">让 IE8 支持 HTML5 语义化标签</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#默认情况下-IE8-对-HTML5-标签的处理"><span class="nav-number">2.1.</span> <span class="nav-text">默认情况下 IE8 对 HTML5 标签的处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何让-IE8-支持-HTML5-标签"><span class="nav-number">2.2.</span> <span class="nav-text">如何让 IE8 支持 HTML5 标签</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#借助-html5shiv-js-让-IE8-支持更多的-HTML5-特性"><span class="nav-number">2.3.</span> <span class="nav-text">借助 html5shiv.js 让 IE8 支持更多的 HTML5 特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#更多阅读"><span class="nav-number">2.4.</span> <span class="nav-text">更多阅读</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#视觉格式化模型（visual-formatting-model）"><span class="nav-number">3.</span> <span class="nav-text">视觉格式化模型（visual formatting model）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#盒子的位置摆放"><span class="nav-number">3.1.</span> <span class="nav-text">盒子的位置摆放</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#格式化上下文（formatting-context）"><span class="nav-number">3.2.</span> <span class="nav-text">格式化上下文（formatting context）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#BFC"><span class="nav-number">3.2.1.</span> <span class="nav-text">BFC</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#块级盒（block-level-boxes）"><span class="nav-number">3.2.1.1.</span> <span class="nav-text">块级盒（block-level boxes）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#渲染规则"><span class="nav-number">3.2.1.2.</span> <span class="nav-text">渲染规则</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IFC"><span class="nav-number">3.2.2.</span> <span class="nav-text">IFC</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#行内级盒（inline-level-boxes）"><span class="nav-number">3.2.2.1.</span> <span class="nav-text">行内级盒（inline-level boxes）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#渲染规则-1"><span class="nav-number">3.2.2.2.</span> <span class="nav-text">渲染规则</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他格式化上下文"><span class="nav-number">3.2.3.</span> <span class="nav-text">其他格式化上下文</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#定位方案"><span class="nav-number">3.3.</span> <span class="nav-text">定位方案</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#常规流（normal-flow）"><span class="nav-number">3.3.1.</span> <span class="nav-text">常规流（normal flow）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#浮动（float）"><span class="nav-number">3.3.2.</span> <span class="nav-text">浮动（float）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#绝对定位（absolute-position）"><span class="nav-number">3.3.3.</span> <span class="nav-text">绝对定位（absolute position）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考资料"><span class="nav-number">3.4.</span> <span class="nav-text">参考资料</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#深入了解-inline-block"><span class="nav-number">4.</span> <span class="nav-text">深入了解 inline-block</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#水平间隙问题"><span class="nav-number">4.1.</span> <span class="nav-text">水平间隙问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#如何消除空白符"><span class="nav-number">4.1.1.</span> <span class="nav-text">如何消除空白符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#代码不换行"><span class="nav-number">4.1.1.1.</span> <span class="nav-text">代码不换行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#设置-font-size"><span class="nav-number">4.1.1.2.</span> <span class="nav-text">设置 font-size</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对齐问题"><span class="nav-number">4.2.</span> <span class="nav-text">对齐问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#中线、基线、顶线、底线"><span class="nav-number">4.2.1.</span> <span class="nav-text">中线、基线、顶线、底线</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vertical-align-的值"><span class="nav-number">4.2.2.</span> <span class="nav-text">vertical-align 的值</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#清除浮动详解"><span class="nav-number">5.</span> <span class="nav-text">清除浮动详解</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#清除前面兄弟元素浮动"><span class="nav-number">5.1.</span> <span class="nav-text">清除前面兄弟元素浮动</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#闭合子元素浮动"><span class="nav-number">5.2.</span> <span class="nav-text">闭合子元素浮动</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#clear-both"><span class="nav-number">5.2.1.</span> <span class="nav-text">clear:both</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#新建-BFC"><span class="nav-number">5.2.2.</span> <span class="nav-text">新建 BFC</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">5.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#深入了解-z-index"><span class="nav-number">6.</span> <span class="nav-text">深入了解 z-index</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#z-index"><span class="nav-number">6.1.</span> <span class="nav-text">z-index</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#层叠上下文"><span class="nav-number">6.2.</span> <span class="nav-text">层叠上下文</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结-1"><span class="nav-number">6.3.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考文档"><span class="nav-number">6.4.</span> <span class="nav-text">参考文档</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#flexbox-剩余空间分配规则"><span class="nav-number">7.</span> <span class="nav-text">flexbox 剩余空间分配规则</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基础概念"><span class="nav-number">7.1.</span> <span class="nav-text">基础概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#flexbox-容器-flexbox-container"><span class="nav-number">7.1.1.</span> <span class="nav-text">flexbox 容器 (flexbox container)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#flexbox-项目-flexbox-item）"><span class="nav-number">7.1.2.</span> <span class="nav-text">flexbox 项目 (flexbox item）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#剩余空间"><span class="nav-number">7.1.3.</span> <span class="nav-text">剩余空间</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剩余空间分配相关属性"><span class="nav-number">7.2.</span> <span class="nav-text">剩余空间分配相关属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#flex-basis"><span class="nav-number">7.2.1.</span> <span class="nav-text">flex-basis</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#flex-grow"><span class="nav-number">7.2.2.</span> <span class="nav-text">flex-grow</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#例子：-只设置-item1-的-flex-grow-为1"><span class="nav-number">7.2.2.1.</span> <span class="nav-text">例子： 只设置 item1 的 flex-grow 为1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#例子：-设置-item1-的-flex-grow-为1，且-item2-的-flex-grow-为3"><span class="nav-number">7.2.2.2.</span> <span class="nav-text">例子： 设置 item1 的 flex-grow 为1，且 item2 的 flex-grow 为3</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如果子元素的宽度的总和超过父容器，flex-grow-将不生效。"><span class="nav-number">7.2.2.3.</span> <span class="nav-text">如果子元素的宽度的总和超过父容器，flex-grow 将不生效。</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#flex-shrink"><span class="nav-number">7.2.3.</span> <span class="nav-text">flex-shrink</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么需要-flex-shrink-来定义缩小比例呢？"><span class="nav-number">7.2.3.1.</span> <span class="nav-text">为什么需要 flex-shrink 来定义缩小比例呢？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#例子：设置项目的flex-shrink"><span class="nav-number">7.2.3.2.</span> <span class="nav-text">例子：设置项目的flex-shrink</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#例子：设置项目的-flex-shrink-为0"><span class="nav-number">7.2.3.3.</span> <span class="nav-text">例子：设置项目的 flex-shrink 为0</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#更多阅读-1"><span class="nav-number">7.3.</span> <span class="nav-text">更多阅读</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#grids-布局系统"><span class="nav-number">8.</span> <span class="nav-text">grids 布局系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#网格系统基础概念"><span class="nav-number">8.1.</span> <span class="nav-text">网格系统基础概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#网格系统基本属性"><span class="nav-number">8.2.</span> <span class="nav-text">网格系统基本属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#父元素（Grid-Container）属性"><span class="nav-number">8.2.1.</span> <span class="nav-text">父元素（Grid Container）属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#子元素（Grid-Item）属性"><span class="nav-number">8.2.2.</span> <span class="nav-text">子元素（Grid Item）属性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实例演示"><span class="nav-number">8.3.</span> <span class="nav-text">实例演示</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#浏览器支持"><span class="nav-number">8.4.</span> <span class="nav-text">浏览器支持</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结-2"><span class="nav-number">8.5.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考资料-1"><span class="nav-number">8.6.</span> <span class="nav-text">参考资料</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#浏览器如何渲染-HTML-amp-CSS"><span class="nav-number">9.</span> <span class="nav-text">浏览器如何渲染 HTML &amp; CSS</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#构建-DOM-树"><span class="nav-number">9.1.</span> <span class="nav-text">构建 DOM 树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CSSOM"><span class="nav-number">9.1.1.</span> <span class="nav-text">CSSOM</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#合并渲染树"><span class="nav-number">9.2.</span> <span class="nav-text">合并渲染树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#布局及绘制"><span class="nav-number">9.3.</span> <span class="nav-text">布局及绘制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考资料-2"><span class="nav-number">9.4.</span> <span class="nav-text">参考资料</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#重排与重绘"><span class="nav-number">10.</span> <span class="nav-text">重排与重绘</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#导致重排和重绘的场景"><span class="nav-number">10.1.</span> <span class="nav-text">导致重排和重绘的场景</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CSS-属性改变"><span class="nav-number">10.1.1.</span> <span class="nav-text">CSS 属性改变</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用户交互"><span class="nav-number">10.1.2.</span> <span class="nav-text">用户交互</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#最佳实践"><span class="nav-number">10.2.</span> <span class="nav-text">最佳实践</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CSS-属性的读、写操作分开"><span class="nav-number">10.2.1.</span> <span class="nav-text">CSS 属性的读、写操作分开</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通过-class-或者-csstext-来批量更新样式"><span class="nav-number">10.2.2.</span> <span class="nav-text">通过 class 或者 csstext 来批量更新样式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他方法"><span class="nav-number">10.2.3.</span> <span class="nav-text">其他方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参看资料"><span class="nav-number">10.3.</span> <span class="nav-text">参看资料</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#水平垂直居中技术"><span class="nav-number">11.</span> <span class="nav-text">水平垂直居中技术</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sponge</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">67.2k</span>
  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'JAytK8dtYmfQUns7Dd8iG9zC-gzGzoHsz',
        appKey: 'Y3ImYMhiFYr5d6sIuyK3ej0Q',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
