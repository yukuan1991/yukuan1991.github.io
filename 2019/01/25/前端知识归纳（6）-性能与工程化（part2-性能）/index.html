<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="performance 详解为了更加精确地测量和提高网页和Web应用程序的性能够，W3C 和各浏览器厂商共同制定了 Web Performance API。 我们可以通过该接口查看用户访问网站各项性能数据，如连接建立时间、dns时间等信息，为更好地增强网页性能提供了前所未有的支持。 浏览器内存相关 performance.memoryperformance.memory 可获取浏览器的内存情况,">
<meta property="og:type" content="article">
<meta property="og:title" content="前端知识归纳（6）-- 性能与工程化（part2 性能）">
<meta property="og:url" content="http://yoursite.com/2019/01/25/前端知识归纳（6）-性能与工程化（part2-性能）/index.html">
<meta property="og:site_name" content="Sponge的个人博客">
<meta property="og:description" content="performance 详解为了更加精确地测量和提高网页和Web应用程序的性能够，W3C 和各浏览器厂商共同制定了 Web Performance API。 我们可以通过该接口查看用户访问网站各项性能数据，如连接建立时间、dns时间等信息，为更好地增强网页性能提供了前所未有的支持。 浏览器内存相关 performance.memoryperformance.memory 可获取浏览器的内存情况,">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/2019/01/25/前端知识归纳（6）-性能与工程化（part2-性能）/performance.png">
<meta property="og:image" content="http://yoursite.com/2019/01/25/前端知识归纳（6）-性能与工程化（part2-性能）/performance-entries.png">
<meta property="og:image" content="http://yoursite.com/2019/01/25/前端知识归纳（6）-性能与工程化（part2-性能）/firstpaint.png">
<meta property="og:image" content="http://yoursite.com/2019/01/25/前端知识归纳（6）-性能与工程化（part2-性能）/firstscreen.png">
<meta property="og:image" content="http://yoursite.com/2019/01/25/前端知识归纳（6）-性能与工程化（part2-性能）/cdn.png">
<meta property="og:updated_time" content="2019-03-20T08:09:01.661Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="前端知识归纳（6）-- 性能与工程化（part2 性能）">
<meta name="twitter:description" content="performance 详解为了更加精确地测量和提高网页和Web应用程序的性能够，W3C 和各浏览器厂商共同制定了 Web Performance API。 我们可以通过该接口查看用户访问网站各项性能数据，如连接建立时间、dns时间等信息，为更好地增强网页性能提供了前所未有的支持。 浏览器内存相关 performance.memoryperformance.memory 可获取浏览器的内存情况,">
<meta name="twitter:image" content="http://yoursite.com/2019/01/25/前端知识归纳（6）-性能与工程化（part2-性能）/performance.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/01/25/前端知识归纳（6）-性能与工程化（part2-性能）/">





  <title>前端知识归纳（6）-- 性能与工程化（part2 性能） | Sponge的个人博客</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Sponge的个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/25/前端知识归纳（6）-性能与工程化（part2-性能）/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sponge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sponge的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">前端知识归纳（6）-- 性能与工程化（part2 性能）</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-25T09:58:57+08:00">
                2019-01-25
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/01/25/前端知识归纳（6）-性能与工程化（part2-性能）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/01/25/前端知识归纳（6）-性能与工程化（part2-性能）/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  5.8k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  22
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="performance-详解"><a href="#performance-详解" class="headerlink" title="performance 详解"></a>performance 详解</h1><p>为了更加精确地测量和提高网页和Web应用程序的性能够，W3C 和各浏览器厂商共同制定了 <strong>Web Performance API</strong>。</p>
<p>我们可以通过该接口查看用户访问网站各项性能数据，如连接建立时间、dns时间等信息，为更好地增强网页性能提供了前所未有的支持。</p>
<h2 id="浏览器内存相关-performance-memory"><a href="#浏览器内存相关-performance-memory" class="headerlink" title="浏览器内存相关 performance.memory"></a>浏览器内存相关 performance.memory</h2><p><code>performance.memory</code> 可获取浏览器的内存情况,这个属性并不是标准的performance 属性，只在 chrome浏览器中。具体有以下值：</p>
<ul>
<li><code>usedJSHeapSize</code> 表示所有被使用的 js 堆栈内存</li>
<li><code>totalJSHeapSize</code> 表示当前 js 堆栈内存总大小</li>
<li><code>jsHeapSizeLimit</code> 表示内存大小限制</li>
</ul>
<p>其中 <code>usedJSHeapSize</code> 不能大于 <code>totalJSHeapSize</code>，如果大于则可能出现了内存泄漏的情况。</p>
<h2 id="网页导航相关-performance-navigation"><a href="#网页导航相关-performance-navigation" class="headerlink" title="网页导航相关 performance.navigation"></a>网页导航相关 performance.navigation</h2><p><code>performance.navigation</code> 对象存储了两个属性，它们表示触发页面加载的原因。这些原因可能是页面重定向、前进后退按钮或者普通的 URL 加载。两个属性如下：</p>
<h3 id="performance-navigation-type"><a href="#performance-navigation-type" class="headerlink" title="performance.navigation.type"></a>performance.navigation.type</h3><p>该属性的值为一个整数值，表示网页的加载来源，共以下4种情况。</p>
<table>
<thead>
<tr>
<th>数值</th>
<th>含义</th>
<th>相应的常量</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>通过点击链接、地址栏输入、表单提交、脚本操作等方式加载。</td>
<td>TYPE_NAVIGATENEXT</td>
</tr>
<tr>
<td>1</td>
<td>通过刷新操作或者 location.reload() 方法</td>
<td>TYPE_RELOAD</td>
</tr>
<tr>
<td>2</td>
<td>通过历史遍历操作加载</td>
<td>TYPE_BACK_FORWARD</td>
</tr>
<tr>
<td>255</td>
<td>其他来源的加载</td>
<td>TYPE_UNDEFINED</td>
</tr>
</tbody>
</table>
<h3 id="performance-navigation-redirectCount"><a href="#performance-navigation-redirectCount" class="headerlink" title="performance.navigation.redirectCount"></a>performance.navigation.redirectCount</h3><p>该属性表示到达当前页面，经过重定向的次数。</p>
<h2 id="时间相关-performance-timing"><a href="#时间相关-performance-timing" class="headerlink" title="时间相关 performance.timing"></a>时间相关 performance.timing</h2><p><code>performance.timing</code> 对象包含了各种浏览器性能相关的信息如网站建立连接、DNS查询、DOM 解析等各项数据，使我们能够更为全面精确地了解网页性能的详细情况。</p>
<p><img src="/2019/01/25/前端知识归纳（6）-性能与工程化（part2-性能）/performance.png" alt="performance.png"></p>
<p>以下是相关的属性：</p>
<ul>
<li><strong>navigationStart</strong>：当前浏览器窗口的前一个网页关闭，发生unload事件时的时间。如果没有上一个页面，这个值会和 <code>fetchStart</code> 相同。通常我们也理解为准备加载新页面的起始时间。</li>
<li><strong>redirectStart</strong>：到当前页面的重定向开始的时间。当重定向的页面来自同一个域时这个属性才会有值，否则值为0。</li>
<li><strong>redirectEnd</strong>：到当前页面的重定向结束的时间。当重定向的页面来自同一个域时这个属性才会有值，否则值为0。</li>
<li><strong>fetchStart</strong>：准备使用HTTP请求(fetch)页面的时间。</li>
<li><strong>domainLookupStart</strong>：域名查询开始的时间。</li>
<li><strong>domainLookupEnd</strong>：域名查询结束的时间。</li>
<li><strong>connectStart</strong>：返回HTTP请求开始向服务器发送的时间,如果使用持久连接（persistent connection），则返回值等同于 <code>fetchStart</code> 的值。</li>
<li><strong>(secureConnectionStart)</strong>：可选特性。如果页面是HTTPS协议，则返回开始SSL握手的那个时间。如果当前网页不要求安全连接，则返回0。</li>
<li><strong>connectEnd</strong>：返回浏览器与服务器之间的连接建立的时间。如果建立的是持久连接，则返回值等同于 <code>fetchStart</code> 属性的值。连接建立指的是所有握手和认证过程全部结束。</li>
<li><strong>requestStart</strong>：返回浏览器向服务器发出HTTP请求时（或开始读取本地缓存时）的时间。</li>
<li><strong>responseStart</strong>：返回浏览器从服务器收到（或从本地缓存读取）第一个字节时的时间。</li>
<li><strong>responseEnd</strong>：返回浏览器从服务器收到（或从本地缓存读取）最后一个字节时的时间。</li>
<li><strong>unloadEventStart</strong>：返回同一个域名前一个网页的 <code>unload</code> 事件触发时的时间。否则返回值为0。</li>
<li><strong>unloadEventEnd</strong>：返回同一个域名前一个网页的 <code>unload</code> 事件触发时的时间。否则返回值为0。</li>
<li><strong>domLoading</strong>：返回当前网页 DOM 结构开始解析时（即Document.readyState属性变为 <code>loading</code>、相应的readystatechange事件触发时）的时间</li>
<li><strong>domInteractive</strong>：返回当前网页DOM结构结束解析、开始加载内嵌资源时（即Document.readyState属性变为 <code>interactive</code> 、相应的readystatechange事件触发时）的时间。</li>
<li><strong>domContentLoadedEventStart</strong>：返回当解析器发送 <code>DOMContentLoaded</code> 事件的开始时间</li>
<li><strong>domContentLoadedEventEnd</strong>：返回当文档的 <code>DOMContentLoaded</code> 事件的结束时间。</li>
<li><strong>domComplete</strong>：返回当前文档解析完成，即Document.readyState 变为 <code>complete</code> 且相对应的readystatechange 被触发时的时间。</li>
<li><strong>loadEventStart</strong>：返回该文档下，<code>load</code> 事件被发送时的时间。如果这个事件还未被发送，它的值将会是0。</li>
<li><strong>loadEventEnd</strong>：返回当 <code>load</code> 事件结束，即加载事件完成时的时间。如果这个事件还未被发送，或者尚未完成，它的值将会是0。</li>
</ul>
<h2 id="计算相关节点"><a href="#计算相关节点" class="headerlink" title="计算相关节点"></a>计算相关节点</h2><p>我们可以通过上面的属性计算出许多网页的信息。</p>
<h3 id="页面经历了多长时间"><a href="#页面经历了多长时间" class="headerlink" title="页面经历了多长时间"></a>页面经历了多长时间</h3><p>如下面代码表示距离浏览器开始加载网页到现在的时间间隔。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var timing = performance.timing; </span><br><span class="line">var duration = Date.now() - timing.navigationStart;</span><br></pre></td></tr></table></figure>
<h3 id="网页加载整个过程的-onload-耗时"><a href="#网页加载整个过程的-onload-耗时" class="headerlink" title="网页加载整个过程的(onload)耗时"></a>网页加载整个过程的(onload)耗时</h3><p>如下面代码表示网页加载整个过程的耗时。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var timing = performance.timing; </span><br><span class="line">var pageLoadTime = timing.loadEventEnd - timing.navigationStart;</span><br></pre></td></tr></table></figure>
<h3 id="DNS-域名解析的耗时"><a href="#DNS-域名解析的耗时" class="headerlink" title="DNS 域名解析的耗时"></a>DNS 域名解析的耗时</h3><p>如下面代码表示 DNS 域名解析的耗时。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var timing = performance.timing; </span><br><span class="line">var dns = timing.domainLookupEnd - timing.domainLookupStart;</span><br></pre></td></tr></table></figure>
<h3 id="tcp-连接的耗时"><a href="#tcp-连接的耗时" class="headerlink" title="tcp 连接的耗时"></a>tcp 连接的耗时</h3><p>如下面代码表示 DNS 域名解析的耗时。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var timing = performance.timing; </span><br><span class="line">var tcp = timing.connectEnd - timing.connectStart;</span><br></pre></td></tr></table></figure>
<h3 id="TTFB-获取首字节的耗时"><a href="#TTFB-获取首字节的耗时" class="headerlink" title="TTFB 获取首字节的耗时"></a>TTFB 获取首字节的耗时</h3><p>如下面代码表示 TTFB(time to frist byte ) 获取首字节的耗时。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var timing = performance.timing; </span><br><span class="line">var ttfb = timing.responseStart - timing.navigationStart;</span><br></pre></td></tr></table></figure>
<h2 id="返回时间-performance-now"><a href="#返回时间-performance-now" class="headerlink" title="返回时间 performance.now()"></a>返回时间 performance.now()</h2><p><code>performance.now</code> 方法将会返回当前网页自从<code>performance.timing.navigationStart</code> 到当前时间之间的微秒数（毫秒的千分之一）。</p>
<p>performance.now() 返回的时间近似于 Date.now()。但前者的时间精度是后者的 1000 倍。</p>
<h2 id="资源加载相关-performance-getEntries"><a href="#资源加载相关-performance-getEntries" class="headerlink" title="资源加载相关 performance.getEntries()"></a>资源加载相关 performance.getEntries()</h2><p>浏览器获取网页时，会对网页中每一个资源文件（js、css、图片等）发出一个HTTP请求。<code>performance.getEntries</code>会统计这些请求并且返回相应的时间信息。</p>
<p>如下所说，返回的是第二个HTTP请求的加载情况：<br><img src="/2019/01/25/前端知识归纳（6）-性能与工程化（part2-性能）/performance-entries.png" alt="performance-entries.png"></p>
<h2 id="更多阅读"><a href="#更多阅读" class="headerlink" title="更多阅读"></a>更多阅读</h2><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/performance" target="_blank" rel="noopener">Window.performance - MDN</a></li>
<li><a href="http://javascript.ruanyifeng.com/bom/performance.html#toc4" target="_blank" rel="noopener">Performance APIß</a></li>
</ul>
<h1 id="Date-类型"><a href="#Date-类型" class="headerlink" title="Date 类型"></a>Date 类型</h1><p>在实际应用中，我们常常需要用到日期或者时间等，而在 JS 中，我们通常使用 Date 类型来表示日期。</p>
<p>由于 JS 中的 Date 类型是在早期 Java 中的 java.util.Date 类基础上构建的，所以 JS 的 Date 类型使用的是自 UTC 1970年1月1日0时0分0秒（世界标准时间）起的毫秒数。比如2017年8月7号16时37分26秒, 用毫秒数表示就是 1502095046000。当然，我们实际使用中不需要手动去计算这些毫秒数，但是要理解这个数字的含义。</p>
<h2 id="日期对象"><a href="#日期对象" class="headerlink" title="日期对象"></a>日期对象</h2><p>通常我们调用 <code>new Date()</code> 获取当前时间，函数返回的是日期对象，这个对象有很多方法可以获取日期的信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 当前时间</span><br><span class="line">var now = new Date(); // Tue Aug 08 2017 15:41:26 GMT+0800 (CST)</span><br></pre></td></tr></table></figure>
<p>除此之外，我们还可以传入参数使用，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var today = new Date(1453094034000); // by timestamp(accurate to the millimeter)</span><br><span class="line">var birthday = new Date(&apos;December 17, 1995 03:24:00&apos;);</span><br><span class="line">var birthday = new Date(&apos;1995-12-17T03:24:00&apos;);</span><br><span class="line">var birthday = new Date(1995, 11, 17);</span><br><span class="line">var birthday = new Date(1995, 11, 17, 3, 24, 0);</span><br></pre></td></tr></table></figure>
<p>其参数规则如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// value 代表自1970年1月1日00:00:00 (世界标准时间) 起经过的毫秒数</span><br><span class="line">new Date(value);</span><br><span class="line"></span><br><span class="line">// 表示日期的字符串值</span><br><span class="line">new Date(dateString);</span><br><span class="line"></span><br><span class="line">// year 代表年份的整数值，为了避免2000年问题最好指定4位数的年份; 如使用 1998, 而不要用 98</span><br><span class="line">// month 代表月份的整数值从0（1月）到11（12月）</span><br><span class="line">// day 代表一个月中的第几天的整数值，从1开始</span><br><span class="line">// hour 代表一天中的小时数的整数值 (24小时制)，minute 分钟数，second 秒数，millisecond 毫秒数</span><br><span class="line">new Date(year, month[, day[, hour[, minutes[, seconds[, milliseconds]]]]]);</span><br></pre></td></tr></table></figure>
<p>注：由于日期对象的方法实在有点多，这里就抽取几个常用的说明下，其余的可参考我们下面的参考资料文章。</p>
<h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><h3 id="now-方法"><a href="#now-方法" class="headerlink" title="now 方法"></a>now 方法</h3><p>es5 中添加了 <code>Date.now()</code> 方法，返回表示调用这个方法时的日期和时间的毫秒数。我们经常用此方法来测试代码的运行时间，这样就可以根据运行时间判断其性能了，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 记录开始时间</span><br><span class="line">var start = Date.now();</span><br><span class="line"></span><br><span class="line">// 这里运行一段代码</span><br><span class="line">doSomething();</span><br><span class="line"></span><br><span class="line">// 记录结束时间</span><br><span class="line">var stop = Date.now();</span><br><span class="line"></span><br><span class="line">// 得到代码运行时间</span><br><span class="line">var timeUse = start - stop;</span><br></pre></td></tr></table></figure>
<p>但是对于不支持 <code>Date.now()</code> 方法的浏览器（如 IE8-），我们还可以使用+操作符把 Date 对象转换成字符串，也可以达到同样的目的，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 记录开始时间</span><br><span class="line">var start = +new Date();</span><br><span class="line"></span><br><span class="line">// 这里运行一段代码</span><br><span class="line">doSomething();</span><br><span class="line"></span><br><span class="line">// 记录结束时间</span><br><span class="line">var stop = +new Date();</span><br><span class="line"></span><br><span class="line">// 得到代码运行时间</span><br><span class="line">var timeUse = start - stop;</span><br></pre></td></tr></table></figure>
<h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><h3 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a>Getter</h3><ul>
<li><code>getFullYear()</code>：根据本地时间返回指定日期对象的年份（四位数年份时返回四位数字）</li>
<li><code>getMonth()</code>：根据本地时间返回指定日期对象的月份（0-11）</li>
<li><code>getDate()</code>：根据本地时间返回指定日期对象的月份中的第几天（1-31）</li>
<li><code>getDay()</code>：根据本地时间返回指定日期对象的星期中的第几天（0-6）</li>
<li><code>getHours()</code>：根据本地时间返回指定日期对象的小时（0-23）</li>
<li><code>getMinutes()</code>：根据本地时间返回指定日期对象的分钟（0-59）</li>
<li><code>getSeconds()</code>：根据本地时间返回指定日期对象的秒数（0-59）</li>
<li><code>getMilliseconds()</code>：根据本地时间返回指定日期对象的微秒（0-999）</li>
<li><code>getTime()</code>：返回从1970-1-1 00:00:00 UTC（协调世界时）到该日期经过的毫秒数，对于1970-1-1 00:00:00 UTC之前的时间返回负值。</li>
</ul>
<p>下面我们以一个简单的格式化时间来说明下上面方法的一些使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 将时间格式化为：YYYY-MM-DD HH:mm:ss</span><br><span class="line"></span><br><span class="line">// 小于或等于9的数字前面添加0</span><br><span class="line">function addZero(num) &#123;</span><br><span class="line">    return num &gt; 9 ? num : &apos;0&apos; + num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 格式化时间，可传入一个时间或使用当前时间</span><br><span class="line">function dateFormat(date) &#123;</span><br><span class="line">    var date = date ? new Date(date) : new Date();</span><br><span class="line">    var str = date.getFullYear() + &apos;-&apos; + addZero(date.getMonth() + 1) + &apos;-&apos; + addZero(date.getDate()) + &apos; &apos; + addZero(date.getHours()) + &apos;:&apos; + addZero(date.getMinutes()) + &apos;:&apos; + addZero(date.getSeconds());</span><br><span class="line"></span><br><span class="line">    return str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dateFormat(); // 2017-08-07 17:44:51</span><br><span class="line">dateFormat(1502095046000); // 2017-08-07 16:37:26</span><br><span class="line">dateFormat(&apos;December 3, 1995 03:19:05&apos;); // 1995-12-03 03:19:05</span><br></pre></td></tr></table></figure>
<p>当然对于格式化时间这么常用的功能，已经有<a href="http://momentjs.cn/" target="_blank" rel="noopener">Moment.js</a>库来帮我们处理了。</p>
<h3 id="Setter"><a href="#Setter" class="headerlink" title="Setter"></a>Setter</h3><ul>
<li><code>setFullYear()</code>：根据本地时间为指定日期对象设置完整年份（四位数年份是四个数字）</li>
<li><code>setMonth()</code>：根据本地时间为指定日期对象设置月份</li>
<li><code>setDate()</code>：根据本地时间为指定的日期对象设置月份中的第几天</li>
<li><code>setHours()</code>：根据本地时间为指定日期对象设置小时数</li>
<li><code>setMinutes()</code>：根据本地时间为指定日期对象设置分钟数</li>
<li><code>setSeconds()</code>：根据本地时间为指定日期对象设置秒数</li>
<li><code>setMilliseconds()</code>：根据本地时间为指定日期对象设置毫秒数</li>
<li><code>setTime()</code>：通过指定从 1970-1-1 00:00:00 UTC 开始经过的毫秒数来设置日期对象的时间，对于早于 1970-1-1 00:00:00 UTC的时间可使用负值。</li>
</ul>
<p>对于该系列的方法，我们经常用于倒计时，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 2017 年 IMWebconf 大会开始时间为： 2017-09-16 09:30:00</span><br><span class="line">// 计算大会时间的倒计时</span><br><span class="line"></span><br><span class="line">var nowTime = Date.now(); // 1502189810994，这个时间会变动</span><br><span class="line"></span><br><span class="line">var confDate = new Date(2017, 8, 16, 9, 30, 0),</span><br><span class="line">    confTime = confDate.getTime(); // 1505525400000</span><br><span class="line"></span><br><span class="line">var diffTime = parseInt((confTime - nowTime) / 1000);</span><br><span class="line"></span><br><span class="line">if(diffTime &gt; 0) &#123;</span><br><span class="line">    var days = parseInt(diffTime / (60 * 60 * 24)); // 得到剩余天数</span><br><span class="line">    var hours = parseInt((diffTime % (60 * 60 * 24)) / (60 * 60)); // 得到剩余小时</span><br><span class="line">    var minutes = parseInt(((diffTime % (60 * 60 * 24)) % (60 * 60)) / 60); // 得到剩余分钟</span><br><span class="line">    var seconds = ((diffTime % (60 * 60 * 24)) % (60 * 60)) % 60; // 得到剩余秒</span><br><span class="line">    // 距离大会还剩38天14:33:9，依赖于 nowTime 为 1502189810994 的计算</span><br><span class="line">    console.log(&apos;距离大会还剩&apos; + days + &apos;天&apos; + hours + &apos;:&apos; + minutes + &apos;:&apos; + seconds);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    console.log(&apos;大会已经圆满结束，敬请期待下一次大会！&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样对于倒计时，也有很多库可用：<a href="http://www.cnblogs.com/lhb25/archive/2012/12/05/12-essential-countdown-timer-scripts.html" target="_blank" rel="noopener">分享12个效果精美的 JavaScript 倒计时脚本</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date" target="_blank" rel="noopener">Date | MDN</a></li>
<li><a href="http://javascript.ruanyifeng.com/stdlib/date.html" target="_blank" rel="noopener">Date对象</a></li>
</ul>
<h1 id="业务中如何计算白屏和首屏时间"><a href="#业务中如何计算白屏和首屏时间" class="headerlink" title="业务中如何计算白屏和首屏时间"></a>业务中如何计算白屏和首屏时间</h1><p>白屏时间和首屏时间是我们衡量网站加载性能的两个重要指标。在开发中，我们需要根据业务页面的具体情况，相应地统计页面白屏时间和首屏时间。对于白屏时间和首屏时间，计算的原理是不变的，但计算的的方式可能会根据页面情况有所改变，因此大家需要具体问题具体分析。</p>
<h2 id="白屏时间"><a href="#白屏时间" class="headerlink" title="白屏时间"></a>白屏时间</h2><p><strong>白屏时间</strong>指的是浏览器开始显示内容的时间。因此我们只需要知道是浏览器开始显示内容的时间点，即页面白屏结束时间点即可获取到页面的白屏时间。</p>
<p><img src="/2019/01/25/前端知识归纳（6）-性能与工程化（part2-性能）/firstpaint.png" alt="firstpaint.png"><br>通过<a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#Painting" target="_blank" rel="noopener">浏览器工作原理</a>，我们可以知道：</p>
<ul>
<li>浏览器在加载页面的刚开始，页面是处于空白的状态，只有当页面发生绘制操作时会开始显示内容。</li>
<li>浏览器加载页面是一个渐进的过程。为达到更好的用户体验，呈现引擎会力求尽快将内容显示在屏幕上。它不必等到整个 HTML 文档解析完毕之后，就会开始构建呈现树和设置布局。在不断接收页面内容的同时，呈现引擎会将部分内容解析并显示出来。</li>
<li>非可视化的 DOM 元素不会显示到窗口中，例如 <code>&lt;head&gt;</code>，这就意味着浏览器在绘制之前，至少需要先解析完head元素中的内容。</li>
</ul>
<h2 id="计算白屏时间"><a href="#计算白屏时间" class="headerlink" title="计算白屏时间"></a>计算白屏时间</h2><p>因此，我们通常认为浏览器开始渲染 <code>&lt;body&gt;</code> 标签或者解析完 <code>&lt;head&gt;</code> 标签的时刻就是页面白屏结束的时间点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;白屏&lt;/title&gt;</span><br><span class="line">  &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    // 不兼容performance.timing 的浏览器，如IE8</span><br><span class="line">    window.pageStartTime = Date.now();</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">  &lt;!-- 页面 CSS 资源 --&gt;</span><br><span class="line">  &lt;link rel=&quot;stylesheet&quot; href=&quot;common.css&quot;&gt;</span><br><span class="line">  &lt;link rel=&quot;stylesheet&quot; href=&quot;page.css&quot;&gt;</span><br><span class="line">  &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    // 白屏时间结束点</span><br><span class="line">    window.firstPaint = Date.now();</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;!-- 页面内容 --&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>因此白屏时间则可以这样计算出：</p>
<h3 id="可使用-Performance-API-时"><a href="#可使用-Performance-API-时" class="headerlink" title="可使用 Performance API 时"></a>可使用 Performance API 时</h3><p><code>白屏时间 = firstPaint - performance.timing.navigationStart;</code></p>
<h3 id="不可使用-Performance-API-时"><a href="#不可使用-Performance-API-时" class="headerlink" title="不可使用 Performance API 时"></a>不可使用 Performance API 时</h3><p><code>白屏时间 = firstPaint - pageStartTime;</code></p>
<h2 id="首屏时间"><a href="#首屏时间" class="headerlink" title="首屏时间"></a>首屏时间</h2><p><strong>首屏时间</strong>是指用户打开网站开始，到浏览器首屏内容渲染完成的时间。对于用户体验来说，首屏时间是用户对一个网站的重要体验因素。通常一个网站，如果首屏时间在5秒以内是比较优秀的，10秒以内是可以接受的，10秒以上就不可容忍了。超过10秒的首屏时间用户会选择刷新页面或立刻离开。</p>
<p><img src="/2019/01/25/前端知识归纳（6）-性能与工程化（part2-性能）/firstscreen.png" alt="firstscreen.png"></p>
<h2 id="计算首屏时间"><a href="#计算首屏时间" class="headerlink" title="计算首屏时间"></a>计算首屏时间</h2><p>明白了<strong>首屏时间</strong>的概念后，我们计算首屏时间则更加清晰了。现实中，不同业务的首屏内容并不是一样的。因此计算首屏时间，需要根据业务页面情况，相应地选择计算首屏时间的方法。</p>
<p>通常计算首屏的方法有</p>
<ul>
<li>首屏模块标签标记法</li>
<li>统计首屏内加载最慢的图片的时间</li>
<li>自定义首屏内容计算法</li>
</ul>
<h3 id="1、首屏模块标签标记法"><a href="#1、首屏模块标签标记法" class="headerlink" title="1、首屏模块标签标记法"></a>1、首屏模块标签标记法</h3><p><strong>首屏模块标签标记法</strong>，通常适用于首屏内容不需要通过拉取数据才能生存以及页面不考虑图片等资源加载的情况。我们会在 HTML 文档中对应首屏内容的标签结束位置，使用内联的 JavaScript 代码记录当前时间戳。如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;首屏&lt;/title&gt;</span><br><span class="line">  &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    window.pageStartTime = Date.now();</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">  &lt;link rel=&quot;stylesheet&quot; href=&quot;common.css&quot;&gt;</span><br><span class="line">  &lt;link rel=&quot;stylesheet&quot; href=&quot;page.css&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;!-- 首屏可见模块1 --&gt;</span><br><span class="line">  &lt;div class=&quot;module-1&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;!-- 首屏可见模块2 --&gt;</span><br><span class="line">  &lt;div class=&quot;module-2&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    window.firstScreen = Date.now();</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">  &lt;!-- 首屏不可见模块3 --&gt;</span><br><span class="line">  &lt;div class=&quot;module-3&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;!-- 首屏不可见模块4 --&gt;</span><br><span class="line">  &lt;div class=&quot;module-4&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>此时<strong>首屏时间</strong>等于 <code>firstScreen - performance.timing.navigationStart;</code></p>
<p>事实上<strong>首屏模块标签标记法</strong> 在业务中的情况比较少，大多数页面都需要通过接口拉取数据才能完整展示，因此我们会使用 JavaScript 脚本来判断首屏页面内容加载情况。</p>
<h3 id="2、统计首屏内图片完成加载的时间"><a href="#2、统计首屏内图片完成加载的时间" class="headerlink" title="2、统计首屏内图片完成加载的时间"></a>2、统计首屏内图片完成加载的时间</h3><p>通常我们首屏内容加载最慢的就是图片资源，因此我们会把<strong>首屏内加载最慢的图片的时间</strong>当做首屏的时间。</p>
<p>由于浏览器对每个页面的 TCP 连接数有限制，使得并不是所有图片都能立刻开始下载和显示。因此我们在 DOM树 构建完成后将会去遍历首屏内的所有图片标签，并且监听所有图片标签 onload 事件，最终遍历图片标签的加载时间的最大值，并用这个最大值减去 <code>navigationStart</code> 即可获得近似的首屏时间。</p>
<p>此时<strong>首屏时间</strong>等于 <code>加载最慢的图片的时间点 - performance.timing.navigationStart;</code></p>
<h3 id="3、自定义模块内容计算法"><a href="#3、自定义模块内容计算法" class="headerlink" title="3、自定义模块内容计算法"></a>3、自定义模块内容计算法</h3><p>由于<strong>统计首屏内图片完成加载的时间</strong>比较复杂。因此我们在业务中通常会通过自定义模块内容，来简化计算首屏时间。如下面的做法：</p>
<ul>
<li>忽略图片等资源加载情况，只考虑页面主要 DOM</li>
<li>只考虑首屏的主要模块，而不是严格意义首屏线以上的所有内容</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对于首屏时间和白屏时间，业界并没有一个统一的计算标准。<strong>大家不能通过死记硬背来实现首屏时间和白屏时间的统计，而应该根据首屏时间和白屏时间的具体原理，切合自身业务情况来制定统计的方法。统计首屏时间和白屏时间是为了让我们能够更明白我们业务页面的情况，而不是为了统计而去统计。</strong></p>
<h2 id="更多阅读-1"><a href="#更多阅读-1" class="headerlink" title="更多阅读"></a>更多阅读</h2><ul>
<li><a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#Painting" target="_blank" rel="noopener">浏览器的工作原理</a></li>
</ul>
<h1 id="优化性能的三大主要手段"><a href="#优化性能的三大主要手段" class="headerlink" title="优化性能的三大主要手段"></a>优化性能的三大主要手段</h1><ul>
<li>减少请求文件数</li>
<li>减少资源体积</li>
<li>提高网络传输</li>
</ul>
<h1 id="CDN-相关"><a href="#CDN-相关" class="headerlink" title="CDN 相关"></a>CDN 相关</h1><p>为了提高网页应用的加载速度，我们会使用到浏览器缓存，然而浏览器缓存只能提升二次访问的速度。对于加速首次访问的速度，我们最常见的手段则是使用 CDN 加速。</p>
<p>CDN 的全称是 <strong>Content Delivery Network</strong>，即内容分发网络。通过将静态资源缓存到离用户很近的相同网络运营商的 CDN 节点上，使用户可以就近取得所需的内容，解决网络拥塞状况，提高用户访问网站的响应速度。</p>
<p><img src="/2019/01/25/前端知识归纳（6）-性能与工程化（part2-性能）/cdn.png" alt="cdn.png"></p>
<p>事实上，在一些较大型的公司来说，通常是由公司的运维开发人员来负责部署 CDN 服务的，前端人员只需要了解使用 CDN 服务的大致流程即可。</p>
<h2 id="1-选择-CDN-供应商"><a href="#1-选择-CDN-供应商" class="headerlink" title="1 选择 CDN 供应商"></a>1 选择 CDN 供应商</h2><p>事实上，现在还有许多的 CDN 服务厂家，我们需要根据需求的情况去选择相应的厂商。现阶段 CDN 云服务商的竞争已经由 <strong>技术</strong> 逐渐取代<strong>价格</strong>成为 CDN 厂商在客户谈判时最关键因素，技术更高的 CDN 服务能够降低带宽成本、提升用户体验。</p>
<p>如今 CDN 各大厂商都会提供十分详尽的接入文档，使我们接入的开发成本变得更低。这里列举国内比较出名的 CDN 厂商：</p>
<ul>
<li><a href="https://www.upyun.com/products/cdn?gclid=EAIaIQobChMImayU6ejE1QIVHL69Ch19bANOEAAYAyAAEgLGY_D_BwE" target="_blank" rel="noopener">叉拍云</a></li>
<li><a href="https://cloud.tencent.com/product/cdn?fromSource=gwzcw.251481.251481.251481&amp;gclid=EAIaIQobChMIpLnk7eHE1QIVVQoqCh3JhwO3EAAYAiAAEgKBJ_D_BwE" target="_blank" rel="noopener">腾讯云</a></li>
<li><a href="https://www.qiniu.com/products/fusion?utm_campaign=googleSEM&amp;utm_source=googleSEM&amp;utm_medium=googleSEM&amp;utm_content=googleSEM&amp;gclid=EAIaIQobChMIpLnk7eHE1QIVVQoqCh3JhwO3EAAYASAAEgIDpvD_BwE" target="_blank" rel="noopener">七牛云</a></li>
<li><a href="https://www.alibabacloud.com/zh?utm_content=se_712562&amp;gclid=EAIaIQobChMIiI7yienE1QIVjgYqCh1RPgD_EAAYASAAEgJRwfD_BwE" target="_blank" rel="noopener">阿里云</a></li>
</ul>
<h2 id="2-连接-CDN-服务"><a href="#2-连接-CDN-服务" class="headerlink" title="2 连接 CDN 服务"></a>2 连接 CDN 服务</h2><p>通常购买了 CDN 服务后，该 CDN 服务会提供相应的接口让我们去上传和部署我们的资源。这部分的工作通常是由我们运维人员去负责的，对于一些小公司可能则需要前端或者后台人员去负责连接 CDN 服务，使业务能够部署静态资源到相应的服务器上。</p>
<h2 id="3-前端工程静态资源部署"><a href="#3-前端工程静态资源部署" class="headerlink" title="3 前端工程静态资源部署"></a>3 前端工程静态资源部署</h2><p>使用 CDN 服务，对前端工程产生了一定的影响，我们需要对静态资源的部署做两项改变：</p>
<h3 id="3-1-将静态资源部署到不同网络线路的服务器中"><a href="#3-1-将静态资源部署到不同网络线路的服务器中" class="headerlink" title="3.1 将静态资源部署到不同网络线路的服务器中"></a>3.1 将静态资源部署到不同网络线路的服务器中</h3><p>由于用户的网络线路有很多种，如网通、电信、移动等，为了让不同地区的用户会访问到离自己最近的相同网络线路上的 CDN 节点。因此我们需要将我们的资源部署到不同的网络线路的服务器中，然后通过这些服务器同步到不同线路的 CDN 节点上。</p>
<h3 id="3-2-加载静态资源时需使用与页面不同的域名"><a href="#3-2-加载静态资源时需使用与页面不同的域名" class="headerlink" title="3.2 加载静态资源时需使用与页面不同的域名"></a>3.2 加载静态资源时需使用与页面不同的域名</h3><p>使用不同的域名来加载 CDN 服务的静态资源，一方面便于接入为 CDN 时设置 DNS 的智能解析。另一方面当静态资源和主页面使用不同的域名，在加载静态资源时 HTTP 请求并不会带上主域页面的 Cookie 等数据，减少了请求时的数据传输量，进一步加快网络访问。</p>
<h3 id="3-3-资源路径的修正"><a href="#3-3-资源路径的修正" class="headerlink" title="3.3 资源路径的修正"></a>3.3 资源路径的修正</h3><p>通常情况下，我们的资源都是在本地，比如有个 JS 文件，我们在 HTML 里面按照相对目录引用它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;js/script.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>使用了 CDN 的话，资源都部署到了 CDN 服务器上去咯，这个时候我们必须用绝对路径来引用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;http://xxx.xxx.xxx/js/script.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>所有啊，必须有个修正资源路径的过程，而这个过程当然不能手动，通常都是在工程化里面解决这个问题。</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>如今 CDN 服务基本上已经成为现代大型网页应用的标配。这项技术是一种十分常用的网络性能优化手段。在未来的前端开发中，我们会经常与 CDN 打交道。因此如果能够清楚了解了 CDN 服务的相关原理和概念，将会让我们在将来的开发中能够更加得心应手。</p>
<h2 id="更多阅读-2"><a href="#更多阅读-2" class="headerlink" title="更多阅读"></a>更多阅读</h2><ul>
<li><a href="https://yusi123.com/3093.html" target="_blank" rel="noopener">盘点国内网站常用的一些CDN公共库加速服务</a></li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/01/23/前端知识归纳（6）-性能与工程化（part1-网络通路简介）/" rel="next" title="前端知识归纳（6）-- 性能与工程化（part1 网络通路简介）">
                <i class="fa fa-chevron-left"></i> 前端知识归纳（6）-- 性能与工程化（part1 网络通路简介）
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/01/28/前端知识归纳（6）-性能与工程化（part3-模块化）/" rel="prev" title="前端知识归纳（6）-- 性能与工程化（part3 模块化）">
                前端知识归纳（6）-- 性能与工程化（part3 模块化） <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Sponge</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">29</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#performance-详解"><span class="nav-number">1.</span> <span class="nav-text">performance 详解</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#浏览器内存相关-performance-memory"><span class="nav-number">1.1.</span> <span class="nav-text">浏览器内存相关 performance.memory</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#网页导航相关-performance-navigation"><span class="nav-number">1.2.</span> <span class="nav-text">网页导航相关 performance.navigation</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#performance-navigation-type"><span class="nav-number">1.2.1.</span> <span class="nav-text">performance.navigation.type</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#performance-navigation-redirectCount"><span class="nav-number">1.2.2.</span> <span class="nav-text">performance.navigation.redirectCount</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#时间相关-performance-timing"><span class="nav-number">1.3.</span> <span class="nav-text">时间相关 performance.timing</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#计算相关节点"><span class="nav-number">1.4.</span> <span class="nav-text">计算相关节点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#页面经历了多长时间"><span class="nav-number">1.4.1.</span> <span class="nav-text">页面经历了多长时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#网页加载整个过程的-onload-耗时"><span class="nav-number">1.4.2.</span> <span class="nav-text">网页加载整个过程的(onload)耗时</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DNS-域名解析的耗时"><span class="nav-number">1.4.3.</span> <span class="nav-text">DNS 域名解析的耗时</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tcp-连接的耗时"><span class="nav-number">1.4.4.</span> <span class="nav-text">tcp 连接的耗时</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TTFB-获取首字节的耗时"><span class="nav-number">1.4.5.</span> <span class="nav-text">TTFB 获取首字节的耗时</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#返回时间-performance-now"><span class="nav-number">1.5.</span> <span class="nav-text">返回时间 performance.now()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#资源加载相关-performance-getEntries"><span class="nav-number">1.6.</span> <span class="nav-text">资源加载相关 performance.getEntries()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#更多阅读"><span class="nav-number">1.7.</span> <span class="nav-text">更多阅读</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Date-类型"><span class="nav-number">2.</span> <span class="nav-text">Date 类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#日期对象"><span class="nav-number">2.1.</span> <span class="nav-text">日期对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#静态方法"><span class="nav-number">2.2.</span> <span class="nav-text">静态方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#now-方法"><span class="nav-number">2.2.1.</span> <span class="nav-text">now 方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实例方法"><span class="nav-number">2.3.</span> <span class="nav-text">实例方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Getter"><span class="nav-number">2.3.1.</span> <span class="nav-text">Getter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Setter"><span class="nav-number">2.3.2.</span> <span class="nav-text">Setter</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考资料"><span class="nav-number">2.4.</span> <span class="nav-text">参考资料</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#业务中如何计算白屏和首屏时间"><span class="nav-number">3.</span> <span class="nav-text">业务中如何计算白屏和首屏时间</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#白屏时间"><span class="nav-number">3.1.</span> <span class="nav-text">白屏时间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#计算白屏时间"><span class="nav-number">3.2.</span> <span class="nav-text">计算白屏时间</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#可使用-Performance-API-时"><span class="nav-number">3.2.1.</span> <span class="nav-text">可使用 Performance API 时</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#不可使用-Performance-API-时"><span class="nav-number">3.2.2.</span> <span class="nav-text">不可使用 Performance API 时</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#首屏时间"><span class="nav-number">3.3.</span> <span class="nav-text">首屏时间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#计算首屏时间"><span class="nav-number">3.4.</span> <span class="nav-text">计算首屏时间</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、首屏模块标签标记法"><span class="nav-number">3.4.1.</span> <span class="nav-text">1、首屏模块标签标记法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、统计首屏内图片完成加载的时间"><span class="nav-number">3.4.2.</span> <span class="nav-text">2、统计首屏内图片完成加载的时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3、自定义模块内容计算法"><span class="nav-number">3.4.3.</span> <span class="nav-text">3、自定义模块内容计算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">3.4.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#更多阅读-1"><span class="nav-number">3.5.</span> <span class="nav-text">更多阅读</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#优化性能的三大主要手段"><span class="nav-number">4.</span> <span class="nav-text">优化性能的三大主要手段</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CDN-相关"><span class="nav-number">5.</span> <span class="nav-text">CDN 相关</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-选择-CDN-供应商"><span class="nav-number">5.1.</span> <span class="nav-text">1 选择 CDN 供应商</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-连接-CDN-服务"><span class="nav-number">5.2.</span> <span class="nav-text">2 连接 CDN 服务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-前端工程静态资源部署"><span class="nav-number">5.3.</span> <span class="nav-text">3 前端工程静态资源部署</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-将静态资源部署到不同网络线路的服务器中"><span class="nav-number">5.3.1.</span> <span class="nav-text">3.1 将静态资源部署到不同网络线路的服务器中</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-加载静态资源时需使用与页面不同的域名"><span class="nav-number">5.3.2.</span> <span class="nav-text">3.2 加载静态资源时需使用与页面不同的域名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-资源路径的修正"><span class="nav-number">5.3.3.</span> <span class="nav-text">3.3 资源路径的修正</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结-1"><span class="nav-number">5.4.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#更多阅读-2"><span class="nav-number">5.5.</span> <span class="nav-text">更多阅读</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sponge</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">65.6k</span>
  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'JAytK8dtYmfQUns7Dd8iG9zC-gzGzoHsz',
        appKey: 'Y3ImYMhiFYr5d6sIuyK3ej0Q',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
